<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (CompilerForCAP) - Chapter 3: Examples and tests</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap3"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapInd.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap3_mj.html">[MathJax on]</a></p>
<p><a id="X7967FE8E7BBDF485" name="X7967FE8E7BBDF485"></a></p>
<div class="ChapSects"><a href="chap3.html#X7967FE8E7BBDF485">3 <span class="Heading">Examples and tests</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7A489A5D79DA9E5C">3.1 <span class="Heading">Examples</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7A810CDA83F2897F">3.2 <span class="Heading">Tests</span></a>
</span>
</div>
</div>

<h3>3 <span class="Heading">Examples and tests</span></h3>

<p><a id="X7A489A5D79DA9E5C" name="X7A489A5D79DA9E5C"></a></p>

<h4>3.1 <span class="Heading">Examples</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FreydCategoriesForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vec := MatrixCategoryAsCategoryOfRows( Q : no_precompiled_code := true );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V := MatrixCategoryObject( vec, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := ZeroMorphism( V, V );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := IdentityMorphism( V );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">W := DirectSum( V, V );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">morphism_matrix := [ [ alpha, beta ], [ beta, alpha ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># compile the derivation of MorphismBetweenDirectSumsWithGivenDirectSums</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Print(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    vec!.added_functions.MorphismBetweenDirectSumsWithGivenDirectSums[1][1],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "\n"</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);</span>
function ( cat, S, diagram_S, morphism_matrix, diagram_T, T )
    local test_diagram_product, test_diagram_coproduct;
    test_diagram_coproduct := ListN( diagram_S, morphism_matrix, 
       function ( source, row )
            return UniversalMorphismIntoDirectSumWithGivenDirectSum( cat, 
               diagram_T, source, row, T );
        end );
    return UniversalMorphismFromDirectSumWithGivenDirectSum( cat, diagram_S, 
       T, test_diagram_coproduct, S );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func2 := CapJitCompiledFunction(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    vec!.added_functions.MorphismBetweenDirectSumsWithGivenDirectSums[1][1],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    vec</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( compiled_func2 );</span>
function ( cat_1, S_1, diagram_S_1, morphism_matrix_1, diagram_T_1, T_1 )
    local hoisted_1_1, deduped_2_1;
    deduped_2_1 := UnderlyingRing( cat_1 );
    hoisted_1_1 := deduped_2_1;
    return CreateCapCategoryMorphismWithAttributes( cat_1, S_1, T_1, 
       UnderlyingMatrix, UnionOfRows( deduped_2_1, Dimension( T_1 ), 
         ListN( diagram_S_1, morphism_matrix_1, 
           function ( logic_new_func_x_2, logic_new_func_y_2 )
                return 
                 UnionOfColumns( hoisted_1_1, Dimension( logic_new_func_x_2 )
                    , List( logic_new_func_y_2, UnderlyingMatrix ) );
            end ) ) );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    CapJitCompiledCAPOperationAsEnhancedSyntaxTree(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        vec, "KernelEmbedding", true</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">) );</span>
function ( cat_1, alpha_1 )
    local morphism_attr_1_1;
    morphism_attr_1_1 := SyzygiesOfRows( UnderlyingMatrix( alpha_1 ) );
    return CreateCapCategoryMorphismWithAttributes( cat_1, 
       CreateCapCategoryObjectWithAttributes( cat_1, Dimension, 
         NumberRows( morphism_attr_1_1 ) ), Source( alpha_1 ), 
       UnderlyingMatrix, morphism_attr_1_1 );
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FreydCategoriesForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "LinearAlgebraForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ReadPackage( "LinearAlgebraForCAP", "gap/CompilerLogic.gi" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ := HomalgFieldOfRationals( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">category_constructor := field -&gt; MatrixCategoryAsCategoryOfRows( field );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">given_arguments := [ QQ ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_category_name := "MatrixCategoryPrecompiled";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">package_name := "LinearAlgebraForCAP";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CapJitPrecompileCategoryAndCompareResult(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    category_constructor,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    given_arguments,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    package_name,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    compiled_category_name :</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    number_of_objectified_objects_in_data_structure_of_object := 1,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    number_of_objectified_morphisms_in_data_structure_of_object := 0,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    number_of_objectified_objects_in_data_structure_of_morphism := 2,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    number_of_objectified_morphisms_in_data_structure_of_morphism := 1</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MatrixCategoryPrecompiled( QQ );</span>
Category of matrices over Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MatrixCategory( QQ )!.precompiled_functions_added;</span>
true
</pre></div>

<p><a id="X7A810CDA83F2897F" name="X7A810CDA83F2897F"></a></p>

<h4>3.2 <span class="Heading">Tests</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "CompilerForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  return List( [ 1, 2 ], x -&gt; x ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitAppliedLogic( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function (  )
    return [ function ( x_2 )
                return x_2;
            end( 1 ), function ( x_2 )
                return x_2;
            end( 2 ) ];
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( L1, L2 )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  return List( Concatenation( L1, L2 ), x -&gt; x ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitAppliedLogic( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function ( L1_1, L2_1 )
    return Concatenation( List( L1_1, function ( x_2 )
              return x_2;
          end ), List( L2_1, function ( x_2 )
              return x_2;
          end ) );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  return Concatenation( [ [ 1, 2, 3, 4 ] ] ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitAppliedLogic( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function (  )
    return [ 1, 2, 3, 4 ];
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  return Concatenation( [ [ 1, 2 ], [ 3, 4 ] ] ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitAppliedLogic( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function (  )
    return [ 1, 2, 3, 4 ];
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  return Concatenation( [ 1, 2 ], [ 3, 4 ] ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitAppliedLogic( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function (  )
    return [ 1, 2, 3, 4 ];
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( my_func )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  return CallFuncList( my_func, [ 1, 2 ] ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitAppliedLogic( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function ( my_func_1 )
    return my_func_1( 1, 2 );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  if 1 = 2 then return 1; elif x = x then return 2; else return 3; fi; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitAppliedLogic( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function ( x_1 )
    if false then
        return 1;
    elif true then
        return 2;
    else
        return 3;
    fi;
    return;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  return Length( [ 1, 2, 3 ] ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitAppliedLogic( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function ( x_1 )
    return 3;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  return [ 1 .. 3 ]; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitAppliedLogic( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function ( x_1 )
    return [ 1, 2, 3 ];
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  return Last( [ 3, 2, 1 ] ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitAppliedLogic( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function ( x_1 )
    return 1;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( list_of_lists )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  return Length( Concatenation( list_of_lists ) ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitAppliedLogic( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function ( list_of_lists_1 )
    return Sum( List( list_of_lists_1, Length ) );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( list1, list2, list3 )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  return Length( Concatenation( list1, list2, list3 ) ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitAppliedLogic( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function ( list1_1, list2_1, list3_1 )
    return Sum( [ Length( list1_1 ), Length( list2_1 ), Length( list3_1 ) ] );
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "CompilerForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># example testing needed_packages</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">template := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    variable_names := [ "name" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    variable_filters := [ "THIS_SHOULD_NOT_BE_PARSED" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    src_template := "THIS_SHOULD_NOT_BE_PARSED_TOO",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    dst_template := "THIS_SHOULD_NOT_BE_PARSED_EITHER",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    needed_packages := [ [ "NON_EXISTING_PACKAGE", "&gt;= 9999" ] ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Add( CAP_JIT_LOGIC_TEMPLATES, template );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( x -&gt; x ) );</span>
function ( x_1 )
    return x_1;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIdenticalObj( Remove( CAP_JIT_LOGIC_TEMPLATES ), template );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">applied_logic_template_to_func :=</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    { func, template, type_signature } -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ENHANCED_SYNTAX_TREE_CODE(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            CAP_JIT_INTERNAL_APPLIED_LOGIC_TEMPLATES(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                CapJitInferredDataTypes(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    ENHANCED_SYNTAX_TREE(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        func :</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        type_signature := type_signature</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                [ template ]</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># some general example</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">template := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    variable_names := [ "variable" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    src_template := "x -&gt; x + variable + x - x",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    dst_template := "x -&gt; x + variable + 0",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CAP_JIT_INTERNAL_ENHANCE_LOGIC_TEMPLATE( template );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( a )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return b -&gt; b + ( 2 * b + a ) + b - b; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( applied_logic_template_to_func( func, template, fail ) );</span>
function ( a_1 )
    return function ( b_2 )
          return b_2 + (2 * b_2 + a_1) + 0;
      end;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># example using EXPR_CASE</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">template := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    variable_names := [ "val1", "val2" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    src_template := "CAP_JIT_INTERNAL_EXPR_CASE( 1 &lt;&gt; 1, val1, true, val2 )",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    dst_template := "val2",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CAP_JIT_INTERNAL_ENHANCE_LOGIC_TEMPLATE( template );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    if 1 &lt;&gt; 1 then return 1; else return 2; fi; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( applied_logic_template_to_func( func, template, fail ) );</span>
function ( )
    return 2;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># check that functions in variables can match</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># and test variable_filters (strings and filters)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">template := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    variable_names := [ "L1", "L2", "func" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    variable_filters := [ "IsList", IsList, IsFunction ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    src_template := "Concatenation( [ List( L1, func ), List( L2, func ) ] )",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    dst_template := "List( Concatenation( [ L1, L2 ] ), func )",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CAP_JIT_INTERNAL_ENHANCE_LOGIC_TEMPLATE( template );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := { L1, L2 } -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Concatenation( [ List( L1, x -&gt; x ), List( L2, x -&gt; x ) ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( applied_logic_template_to_func(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    func,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    template,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            rec( filter := IsList, element_type := rec( filter := IsInt ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            rec( filter := IsList, element_type := rec( filter := IsInt ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        fail,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ]</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">) );</span>
function ( L1_1, L2_1 )
    return List( Concatenation( [ L1_1, L2_1 ] ), function ( x_2 )
            return x_2;
        end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># check that template is not executed if data types cannot be determined</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Display( applied_logic_template_to_func( func, template, fail ) );</span>
function ( L1_1, L2_1 )
    return Concatenation( [ List( L1_1, function ( x_2 )
              return x_2;
          end ), List( L2_1, function ( x_2 )
              return x_2;
          end ) ] );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># check that template is only applied if filters match</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">template := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    variable_names := [ "value" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    variable_filters := [ IsInt ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    src_template := "Sum( [ value ] )",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    dst_template := "value",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CAP_JIT_INTERNAL_ENHANCE_LOGIC_TEMPLATE( template );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := { x } -&gt; Sum( [ x ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( applied_logic_template_to_func(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    func,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    template,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            rec( filter := IsInt ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        fail,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ]</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">) );</span>
function ( x_1 )
    return x_1;
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( applied_logic_template_to_func(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    func,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    template,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            rec( filter := IsFloat ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        fail,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ]</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">) );</span>
function ( x_1 )
    return Sum( [ x_1 ] );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># check that functions can be used multiple times in dst_template</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># add a nonsense template</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">template := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    variable_names := [ "list", "value" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    src_template := "List( list, l -&gt; value )",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    dst_template := "Sum( list, l -&gt; value ) + Sum( list, l -&gt; value )",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CAP_JIT_INTERNAL_ENHANCE_LOGIC_TEMPLATE( template );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( list )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return List( list, x -&gt; x ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( applied_logic_template_to_func( func, template, fail ) );</span>
function ( list_1 )
    return Sum( list_1, function ( x_2 )
              return x_2;
          end ) + Sum( list_1, function ( x_2 )
              return x_2;
          end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( list )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return List( list, x -&gt; (y -&gt; y) ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( applied_logic_template_to_func( func, template, fail ) );</span>
function ( list_1 )
    return Sum( list_1, function ( x_2 )
              return function ( y_3 )
                    return y_3;
                end;
          end ) + Sum( list_1, function ( x_2 )
              return function ( y_3 )
                    return y_3;
                end;
          end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># check that functions with assignments to local variables do not match</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># logic templates without assignments to local variables</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">template := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    variable_names := [ "value" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    src_template := "List( [ 1 ], l -&gt; value )",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    dst_template := "(l -&gt; value)(1)",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CAP_JIT_INTERNAL_ENHANCE_LOGIC_TEMPLATE( template );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function ( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return List( [ 1 ], function ( y )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        local r; r := x; return r; end ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( applied_logic_template_to_func( func, template, fail ) );</span>
function ( x_1 )
    return List( [ 1 ], function ( y_2 )
            local r_2;
            r_2 := x_1;
            return r_2;
        end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># check that values are pulled out iff</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># they are independent of local variables</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">template := rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    variable_names := [ "list", "value" ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    src_template := "List( list, l -&gt; value * l )",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    dst_template := "value * List( list, l -&gt; l )",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CAP_JIT_INTERNAL_ENHANCE_LOGIC_TEMPLATE( template );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := L -&gt; List( L, l -&gt; l * l );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( applied_logic_template_to_func( func, template, fail ) );</span>
function ( L_1 )
    return List( L_1, function ( l_2 )
            return l_2 * l_2;
        end );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := L -&gt; List( L, l -&gt; 2 * l );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( applied_logic_template_to_func( func, template, fail ) );</span>
function ( L_1 )
    return 2 * List( L_1, function ( l_2 )
              return l_2;
          end );
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "CompilerForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := x -&gt; MatElm( x, 1, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := ENHANCED_SYNTAX_TREE( func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tree := CapJitResolvedGlobalVariables( tree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( ENHANCED_SYNTAX_TREE_CODE( tree ) );</span>
function ( x_1 )
    return \[\,\]( x_1, 1, 1 );
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FreydCategoriesForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ReadPackage( "FreydCategoriesForCAP",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "gap/CategoryOfRowsAsAdditiveClosureOfRingAsCategory_CompilerLogic.gi");</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ := HomalgFieldOfRationalsInSingular( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQxy := QQ * "x,y";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EQQxy := KoszulDualRing( QQxy );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := KoszulDualRing( HomalgRingOfIntegersInSingular( ) * "x,y" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_CategoryOfColumns := function( homalg_ring, name )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    CapJitPrecompileCategoryAndCompareResult(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        homalg_ring -&gt; CategoryOfColumnsAsOppositeOfCategoryOfRows(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            homalg_ring</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [ homalg_ring ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "FreydCategoriesForCAP",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        Concatenation(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            "CategoryOfColumnsAsOppositeOfCategoryOfRowsOf",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            name,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            "Precompiled"</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ) :</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        operations := "primitive",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        number_of_objectified_objects_in_data_structure_of_object := 1,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        number_of_objectified_morphisms_in_data_structure_of_object := 0,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        number_of_objectified_objects_in_data_structure_of_morphism := 2,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        number_of_objectified_morphisms_in_data_structure_of_morphism := 1</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_CategoryOfColumns( QQ, "Field" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_CategoryOfColumns( QQxy, "CommutativeRing" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_CategoryOfColumns( EQQxy, "HomalgExteriorRingOverField" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_CategoryOfColumns( R, "ArbitraryRing" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CategoryOfColumns( QQ )!.precompiled_functions_added;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CategoryOfColumns( QQxy )!.precompiled_functions_added;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CategoryOfColumns( EQQxy )!.precompiled_functions_added;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CategoryOfColumns( R )!.precompiled_functions_added;</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FreydCategoriesForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ReadPackage( "FreydCategoriesForCAP",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "gap/CategoryOfRowsAsAdditiveClosureOfRingAsCategory_CompilerLogic.gi");</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ := HomalgFieldOfRationalsInSingular( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQxy := QQ * "x,y";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EQQxy := KoszulDualRing( QQxy );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := KoszulDualRing( HomalgRingOfIntegersInSingular( ) * "x,y" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom_structure_operations := [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "DistinguishedObjectOfHomomorphismStructure",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "HomomorphismStructureOnObjects",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "HomomorphismStructureOnMorphismsWithGivenObjects",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Concatenation(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "InterpretMorphismAsMorphismFromDistinguishedObject",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "ToHomomorphismStructureWithGivenObjects"</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Concatenation(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "InterpretMorphismFromDistinguishedObject",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "ToHomomorphismStructureAsMorphism"</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_CategoryOfRows := function( homalg_ring, name, operations )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    CapJitPrecompileCategoryAndCompareResult(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        homalg_ring -&gt; CategoryOfRowsAsAdditiveClosureOfRingAsCategory(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            homalg_ring</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [ homalg_ring ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "FreydCategoriesForCAP",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        Concatenation(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            "CategoryOfRowsAsAdditiveClosureOfRingAsCategoryOf",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            name,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            "Precompiled"</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ) :</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        operations := operations,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        number_of_objectified_objects_in_data_structure_of_object := 1,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        number_of_objectified_morphisms_in_data_structure_of_object := 0,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        number_of_objectified_objects_in_data_structure_of_morphism := 2,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        number_of_objectified_morphisms_in_data_structure_of_morphism := 1</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_CategoryOfRows(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    QQ, "Field", hom_structure_operations</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_CategoryOfRows(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    QQxy, "CommutativeRing", hom_structure_operations</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_CategoryOfRows(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    EQQxy, "HomalgExteriorRingOverField", hom_structure_operations</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_CategoryOfRows(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    R, "ArbitraryRing", [ ]</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CategoryOfRows( QQ )!.precompiled_functions_added;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CategoryOfRows( QQxy )!.precompiled_functions_added;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CategoryOfRows( EQQxy )!.precompiled_functions_added;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CategoryOfRows( R )!.precompiled_functions_added;</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FreydCategoriesForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">dummy := DummyCategory( rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    list_of_operations_to_install := [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        # general category</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "PreCompose",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "IdentityMorphism",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "IsEqualForMorphisms",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "IsEqualForMorphismsOnMor",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "IsWellDefinedForMorphisms",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        # computable</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "IsCongruentForMorphisms",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        # pre-additive</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "AdditionForMorphisms",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "SubtractionForMorphisms",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "AdditiveInverseForMorphisms",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "ZeroMorphism",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        # with zero object</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "ZeroObject",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "UniversalMorphismIntoZeroObject",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "UniversalMorphismFromZeroObject",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "ZeroObjectFunctorial",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        # additive</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "DirectSum",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "DirectSumFunctorial",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "ProjectionInFactorOfDirectSum",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "UniversalMorphismIntoDirectSum",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "InjectionOfCofactorOfDirectSum",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "UniversalMorphismFromDirectSum",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        # colifts</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "IsColiftable"</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    properties := [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "IsAdditiveCategory",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StopCompilationAtPrimitivelyInstalledOperationsOfCategory( dummy );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CapJitPrecompileCategoryAndCompareResult(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    underlying_category -&gt; CoFreydCategoryAsOppositeOfFreydCategoryOfOpposite(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        underlying_category</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [ dummy ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "FreydCategoriesForCAP",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "CoFreydCategoryAsOppositeOfFreydCategoryOfOppositePrecompiled" :</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    operations := "primitive",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    number_of_objectified_objects_in_data_structure_of_object := 1,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    number_of_objectified_morphisms_in_data_structure_of_object := 0,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    number_of_objectified_objects_in_data_structure_of_morphism := 2,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    number_of_objectified_morphisms_in_data_structure_of_morphism := 1</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CoFreydCategory( dummy )!.precompiled_functions_added;</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "ModulePresentationsForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ReadPackage( "LinearAlgebraForCAP", "gap/CompilerLogic.gi" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ := HomalgFieldOfRationalsInSingular( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQxy := QQ * "x,y";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EEE := KoszulDualRing( QQxy * "a,b" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># CAUTION: when adding new operations make sure that they are compatible</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># with the ones added manually in `ADD_FUNCTIONS_FOR_LEFT/RIGHT_PRESENTATION`.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">operations_for_arbitrary_ring := [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "AdditionForMorphisms",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "AdditiveInverseForMorphisms",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"AssociatorLeftToRightWithGivenTensorProducts",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"AssociatorRightToLeftWithGivenTensorProducts",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"BraidingWithGivenTensorProducts",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"CoevaluationMorphismWithGivenRange",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "CokernelColiftWithGivenCokernelObject",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "CokernelProjection",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"Colift",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"ColiftOrFail",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "DirectSum",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "EpimorphismFromSomeProjectiveObject",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"EvaluationMorphismWithGivenSource",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "IdentityMorphism",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "InjectionOfCofactorOfDirectSumWithGivenDirectSum",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"InternalHomOnMorphismsWithGivenInternalHoms",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"InternalHomOnObjects",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"IsColiftable",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "IsCongruentForMorphisms",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "IsEqualForMorphisms",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"IsEqualForObjects",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"IsLiftable",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"IsWellDefinedForMorphisms",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"IsWellDefinedForObjects",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "IsZeroForMorphisms",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"KernelEmbedding",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"LeftUnitorWithGivenTensorProduct",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"Lift",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"LiftAlongMonomorphism",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"LiftOrFail",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"MultiplyWithElementOfCommutativeRingForMorphisms",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"PreCompose",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "ProjectionInFactorOfDirectSumWithGivenDirectSum",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"RightUnitorWithGivenTensorProduct",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"TensorProductOnMorphismsWithGivenTensorProducts",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"TensorProductOnObjects",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #"TensorUnit",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "UniversalMorphismFromDirectSumWithGivenDirectSum",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "UniversalMorphismFromZeroObjectWithGivenZeroObject",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "UniversalMorphismIntoDirectSumWithGivenDirectSum",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "UniversalMorphismIntoZeroObjectWithGivenZeroObject",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "ZeroMorphism",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "ZeroObject" </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">operations_for_commutative_ring := Concatenation(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    operations_for_arbitrary_ring,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [ "MultiplyWithElementOfCommutativeRingForMorphisms" ]</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_LeftPresentations := function( ring, name, operations )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    CapJitPrecompileCategoryAndCompareResult(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ring -&gt; LeftPresentationsAsFreydCategoryOfCategoryOfRows( ring ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [ ring ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "ModulePresentationsForCAP",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        Concatenation(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            "LeftPresentationsAsFreydCategoryOfCategoryOfRowsOf",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            name,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            "Precompiled"</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ) :</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        operations := operations</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_LeftPresentations(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    QQ, "Field", operations_for_commutative_ring</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_LeftPresentations(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    QQxy, "CommutativeRing", operations_for_commutative_ring</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_LeftPresentations(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    EEE, "ArbitraryRing", operations_for_arbitrary_ring</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_RightPresentations := function( ring, name, operations )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    CapJitPrecompileCategoryAndCompareResult(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ring -&gt; RightPresentationsAsFreydCategoryOfCategoryOfColumns( ring ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [ ring ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        "ModulePresentationsForCAP",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        Concatenation(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            "RightPresentationsAsFreydCategoryOfCategoryOfColumnsOf",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            name,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            "Precompiled"</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ) :</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        operations := operations,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        number_of_objectified_objects_in_data_structure_of_object := 1,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        number_of_objectified_morphisms_in_data_structure_of_object := 0,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        number_of_objectified_objects_in_data_structure_of_morphism := 2,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        number_of_objectified_morphisms_in_data_structure_of_morphism := 1</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_RightPresentations(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    QQ, "Field", operations_for_commutative_ring</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_RightPresentations(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    QQxy, "CommutativeRing", operations_for_commutative_ring</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">precompile_RightPresentations(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    EEE, "ArbitraryRing", operations_for_arbitrary_ring</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LeftPresentations( QQ )!.precompiled_functions_added;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LeftPresentations( QQxy )!.precompiled_functions_added;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LeftPresentations( EEE )!.precompiled_functions_added;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RightPresentations( QQ )!.precompiled_functions_added;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RightPresentations( QQxy )!.precompiled_functions_added;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RightPresentations( EEE )!.precompiled_functions_added;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># put the letter 'V' here to work around</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># https://github.com/frankluebeck/GAPDoc/pull/61</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"></span>
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "LinearAlgebraForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ := HomalgFieldOfRationals( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># be careful not to use `MatrixCategory` because attributes are not supported</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">category_constructor := function( field )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return Opposite(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        MATRIX_CATEGORY(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            field :</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            no_precompiled_code := false, FinalizeCategory := true</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ) :</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        only_primitive_operations := true</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">given_arguments := [ QQ ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_category_name := "OppositeOfMatrixCategoryPrecompiled";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">package_name := "LinearAlgebraForCAP";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CapJitPrecompileCategoryAndCompareResult(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    category_constructor,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    given_arguments,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    package_name,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    compiled_category_name :</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    operations := "primitive",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    number_of_objectified_objects_in_data_structure_of_object := 2,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    number_of_objectified_morphisms_in_data_structure_of_object := 0,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    number_of_objectified_objects_in_data_structure_of_morphism := 6,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    number_of_objectified_morphisms_in_data_structure_of_morphism := 2</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ReadPackage(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "LinearAlgebraForCAP",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "gap/precompiled_categories/OppositeOfMatrixCategoryPrecompiled.gi"</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OppositeOfMatrixCategoryPrecompiled( QQ );</span>
Opposite of Category of matrices over Q
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FreydCategoriesForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ := HomalgFieldOfRationals( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vec := CategoryOfRows( QQ : no_precompiled_code );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := cat -&gt; ZeroObjectFunctorial( cat );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StopCompilationAtCategory( vec );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( func, vec ) );</span>
function ( cat_1 )
    return ZeroObjectFunctorial( cat_1 );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ContinueCompilationAtCategory( vec );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( func, vec ) );</span>
function ( cat_1 )
    local morphism_attr_1_1, deduped_2_1;
    deduped_2_1 := CreateCapCategoryObjectWithAttributes( cat_1, 
       RankOfObject, 0 );
    morphism_attr_1_1 := HomalgZeroMatrix( 0, 0, UnderlyingRing( cat_1 ) );
    return CreateCapCategoryMorphismWithAttributes( cat_1, deduped_2_1, 
       deduped_2_1, UnderlyingMatrix, morphism_attr_1_1 );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vec := CategoryOfRows( QQ : no_precompiled_code );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">StopCompilationAtPrimitivelyInstalledOperationsOfCategory( vec );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( func, vec ) );</span>
function ( cat_1 )
    local deduped_1_1;
    deduped_1_1 := ZeroObject( cat_1 );
    return ZeroMorphism( cat_1, deduped_1_1, deduped_1_1 );
end
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ContinueCompilationAtPrimitivelyInstalledOperationsOfCategory( vec );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CapJitCompiledFunction( func, vec ) );</span>
function ( cat_1 )
    local morphism_attr_1_1, deduped_2_1;
    deduped_2_1 := CreateCapCategoryObjectWithAttributes( cat_1, 
       RankOfObject, 0 );
    morphism_attr_1_1 := HomalgZeroMatrix( 0, 0, UnderlyingRing( cat_1 ) );
    return CreateCapCategoryMorphismWithAttributes( cat_1, deduped_2_1, 
       deduped_2_1, UnderlyingMatrix, morphism_attr_1_1 );
end
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func1 := function( x, y )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    #% CAP_JIT_RESOLVE_FUNCTION</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    return x; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func2 := function( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  local var; var := 1; var := func1( 2, var ); return var; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func := CapJitCompiledFunction( func2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compiled_func();</span>
2
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">func := function( )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  local id; id := y -&gt; y; return [ id, id ]; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># we are not interested in the output, but only that this does not throw</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"># an error due to some function id being used multiple times</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">CapJitCompiledFunction( func );;</span>
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapInd.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
