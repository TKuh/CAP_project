<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (CompilerForCAP) - Chapter 1: Using the compiler</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap1"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap2.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap1_mj.html">[MathJax on]</a></p>
<p><a id="X8465664B7FDF3EDA" name="X8465664B7FDF3EDA"></a></p>
<div class="ChapSects"><a href="chap1.html#X8465664B7FDF3EDA">1 <span class="Heading">Using the compiler</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X8578A2598059B94F">1.1 <span class="Heading">Terminology</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X83E04B937E74DD2A">1.2 <span class="Heading">Capabilities of the compiler</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X85A08CF187A6D986">1.3 <span class="Heading">Requirements</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X8307AD6B823FB122">1.4 <span class="Heading">Precompiling categories</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X81627716853DCE40">1.4-1 CapJitPrecompileCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X819343157D62111A">1.4-2 CapJitPrecompileCategoryAndCompareResult</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X78F1B59B7DBEF671">1.5 <span class="Heading">Compiling a function manually</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X87BAEADB78CC3FF0">1.5-1 CapJitCompiledCAPOperationAsEnhancedSyntaxTree</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X86F1D06C81670DC8">1.5-2 CapJitCompiledFunction</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7B1445EE85D8CA0A">1.5-3 CapJitCompiledFunctionAsEnhancedSyntaxTree</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X7E61259E7D6E8EEB">1.6 <span class="Heading">Giving hints to the compiler</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X7C1A71BB7DC16DDF">1.7 <span class="Heading">Stopping the compiler at a certain level</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X85B3DF4C80406968">1.7-1 StopCompilationAtCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7ECBAF2483705ED2">1.7-2 ContinueCompilationAtCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X80ABBF057E2687E1">1.7-3 StopCompilationAtPrimitivelyInstalledOperationsOfCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X86EE97ED7A87D7CC">1.7-4 ContinueCompilationAtPrimitivelyInstalledOperationsOfCategory</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X7F76759D7D772538">1.8 <span class="Heading">Disabling the automatic inference of data types</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X843286607CD2DE7E">1.8-1 CapJitDisableDataTypeInference</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X846C79BA815F795A">1.9 <span class="Heading">Compiling step-by-step</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7B02F25F82DD0F3A">1.9-1 CapJitEnableStepByStepCompilation</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X8517503D80444503">1.10 <span class="Heading">Proof assistant mode</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X795104B985A220EE">1.10-1 CapJitEnableProofAssistantMode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7EB255567AF094DA">1.10-2 StateLemma</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X8434101E7B6EE619">1.10-3 PrintLemma</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X81348DC479E3E23A">1.10-4 AttestValidInputs</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X808B685A86A2F034">1.10-5 ApplyLogicTemplate</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X8474951D8027E03C">1.10-6 ApplyLogicTemplateNTimes</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X8713ECB6806939C0">1.10-7 AssertLemma</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X7BA4D059800749B3">1.10-8 StateProposition</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X80E20DF57D20BB5B">1.10-9 StateNextLemma</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X79477D7D783D70D3">1.10-10 AssertProposition</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X7B946AD083F7CEEA">1.11 <span class="Heading">Getting information about the compilation process</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X8202365E84A044DC">1.11-1 InfoCapJit</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1.html#X83CA158B7F828620">1.11-2 CapJitSetDebugLevel</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1.html#X780099B481AB3AB7">1.12 <span class="Heading">FAQ</span></a>
</span>
</div>
</div>

<h3>1 <span class="Heading">Using the compiler</span></h3>

<p><a id="X8578A2598059B94F" name="X8578A2598059B94F"></a></p>

<h4>1.1 <span class="Heading">Terminology</span></h4>

<p>The compiler was started as a just-in-time compiler, that is, it needed some arguments to infer types of variables. Although the compiler now supports precompilation and type signatures can be explicitly given, it still is a just-in-time compiler in the following sense: Only methods for operations getting a CAP category as the first argument can be found by the compiler, and an instance of a CAP category is needed for method selection.</p>

<p>The compiler uses GAP's syntax trees for optimizing functions. The term <em>tree</em> always refers to the syntax tree of the function to be compiled. Note that a node of the tree always knows its children, so technically it is also a tree. That is, the terms <em>tree</em>, <em>subtree</em>, and <em>node</em> technically describe the same thing but we use them for different emphases.</p>

<p>We often replace a node in the tree by another tree representing the "value" of the original node. Examples:</p>


<ul>
<li><p>Replace a global variable referencing an integer, a string, or a boolean by EXPR_INT, EXPR_STRING, EXPR_TRUE or EXPR_FALSE.</p>

</li>
<li><p>Replace a global variable referencing a plain function by the syntax tree of this function.</p>

</li>
<li><p>Replace a record access of a global function by the value of this record access.</p>

</li>
<li><p>Replace an operation by a concrete method.</p>

</li>
</ul>
<p>We call this <em>resolving</em> the global variable, operation, etc. Note that this does not change the basic "layout" of the tree.</p>

<p>On the contrary, in the following examples we change the "layout" of the tree:</p>


<ul>
<li><p>If we have a function call of a resolved function, we can assign the argument values to local variables at the beginning of the function. This way we can avoid passing arguments completely.</p>

</li>
<li><p>If a function call of a resolved function occurs in the right hand side of a variable assignment, we can insert the body of the resolved function right before the variable assignment. This way we can avoid the function call.</p>

</li>
<li><p>We can replace all references to a local variable by the right hand side of the variable assignment and then drop the assignment.</p>

</li>
</ul>
<p>We call this <em>inlining</em> the function arguments, functions, or variable assignments.</p>

<p><a id="X83E04B937E74DD2A" name="X83E04B937E74DD2A"></a></p>

<h4>1.2 <span class="Heading">Capabilities of the compiler</span></h4>

<p>The compilation process has two phases: the resolving phase and the rule phase.</p>

<p>During the resolving phase, operations and global variables are resolved.</p>


<ul>
<li><p>CAP operations can only be resolved if an instance of a CAP category to which the operation is applied is known. Then, the functions added to the category via <code class="code">Add</code> functions are considered. Note that caching, pre functions, etc. are bypassed.</p>

</li>
<li><p>You can also use <code class="code">InstallMethodForCompilerForCAP</code> or <code class="code">InstallOtherMethodForCompilerForCAP</code> (see the documentation of CAP) to make methods which accept a CAP category as the first argument known to the compiler. The same restrictions as for CAP operations apply.</p>

</li>
<li><p>References to global functions are resolved if the function name is not listed in <code class="code">CAP_JIT_NON_RESOLVABLE_GLOBAL_VARIABLE_NAMES</code> and if the function is annotated with the pragma <code class="code">CAP_JIT_RESOLVE_FUNCTION</code>.</p>

</li>
<li><p>If a call of a global function or operation (occuring as the right hand side of a variable assignment or as the return value of a function) is annotated with the pragma <code class="code">CAP_JIT_NEXT_FUNCCALL_DOES_NOT_RETURN_FAIL</code>, the compiler assumes that the resolved function never returns <code class="code">fail</code> and thus simply removes any code of the form <code class="code">if condition then return fail; fi;</code> (or similar) from the resolved function. The pragma has to be placed right before the variable assignment or the return statement.</p>

</li>
<li><p>If the pragma <code class="code">CAP_JIT_DROP_NEXT_STATEMENT</code> occurs in the resolved function, the statement following the pragma is removed.</p>

</li>
</ul>
<p>For details see <code class="func">CapJitResolvedOperations</code> (<a href="chap2.html#X7D12C378812745DA"><span class="RefLink">2.5-21</span></a>) and <code class="func">CapJitResolvedGlobalVariables</code> (<a href="chap2.html#X7FD883BA85F7EBE5"><span class="RefLink">2.5-20</span></a>). If no operation or global variable can be resolved anymore, we continue with the rule phase.</p>

<p>In the rule phase, the tree is optimized using several rules and techniques. Function arguments, functions, and assignments to local variables are inlined. Unused variables are dropped. Handled edge cases are dropped, that is, if the same edge case is caught multiple times via <code class="code">if condition then return ...; fi;</code> statements, only the first such statement is kept. Finally, "logic" is applied to the tree. For example, calls of <code class="code">CallFuncList</code> are replaced by calls to the actual function. The logic can be extended by the user, see chapter <a href="chap2.html#X7D62EFD07F991E56"><span class="RefLink">2</span></a>.</p>

<p>For all details, see the list of compilations steps in <a href="chap2.html#X80608A9A78CF95E0"><span class="RefLink">2.5</span></a>.</p>

<p><a id="X85A08CF187A6D986" name="X85A08CF187A6D986"></a></p>

<h4>1.3 <span class="Heading">Requirements</span></h4>

<p>There are some requirements for the steps described above to be correct.</p>

<p>The code must be <em>purely functional</em>, that is, it must have the following properties:</p>


<ul>
<li><p>The code must not depend on side effects (otherwise dropping "unused" variables or inlining variables could change results).</p>

</li>
<li><p>Only assignments to local variables, if/elif/else statements, and return statements are allowed as statements in functions.</p>

</li>
<li><p>All branches of any given if/elif/else statement must end with a return statement or the assignment to the same local variable (so if/elif/else statements can be handled as expressions).</p>

</li>
<li><p>If statements must always have an else statement, except if all branches end with a return statement. In the latter case, the statements following the if statement are automatically put into an else statement.</p>

</li>
<li><p>Local variables must be assigned at most once (this includes function arguments, which are assigned at least once, namely when the function is called). An exception is made for "rapid reassignments": if the same variable is assigned and then reassigned immediately in the next statement, this only counts as a single assignment.</p>

</li>
<li><p>Since the compiler might change the order of statements, checking if a local variable (or list entry etc.) is bound is not safe.</p>

</li>
</ul>
<p>GAP has <em>strict semantics</em>, that is, the evaluation of an expression first evaluates all subexpressions, and if an error occurs during the evaluation of a subexpression, the evaluation of the outer expression also stops. However, CompilerForCAP has some optimizations which are only valid with non-strict semantics. These optimizations produce subexpression which are not computed in the original code and are not needed for the final result. With GAP's strict semantics, those subexpressions are still evaluated despite not being needed for the final result. Hence, those subexpressions must not throw an error when evaluated. In particular:</p>


<ul>
<li><p>For performance optimizations, the compiler might move expressions out of if/else statements, e.g. if they occur inside a (potentially expensive) <code class="code">List</code> call. Thus, code inside if/else statements must execute without error even if moved outside of the if/else statement.</p>

</li>
<li><p>More generally, hoisting expressions might lead to subexpressions being evaluated which were not being evaluated before. For example, the subexpression <code class="code">mat[i]</code> in the uncompiled code <code class="code">i -&gt; List( [ ], j -&gt; mat[i][j] )</code> is never evaluated due to the domain of <code class="code">j</code> being empty, but CompilerForCAP will hoist <code class="code">mat[i]</code> out of the <code class="code">List</code> call, so after compilation <code class="code">mat[i]</code> might be evaluated.</p>

</li>
<li><p>Functions which are applied to an element of a list must be applicable to all elements of this list.</p>

</li>
</ul>
<p>Furthermore, there are some technical restrictions:</p>


<ul>
<li><p>Nested if/elif/else statements are not allowed.</p>

</li>
<li><p>Function arguments or local variables must not be called <code class="code">RETURN_VALUE</code>, as this name is used internally.</p>

</li>
<li><p>Non-dense lists are not supported.</p>

</li>
<li><p>There is no detection for recursive function calls, so resolving such a function call leads to an infinite loop.</p>

</li>
</ul>
<p>Also note that technically the result of the compilation is only valid for the concrete CAP category which was used to resolve CAP operations and get typing information. That is, for parametric categories you must check manually for which parameters the result is valid.</p>

<p><a id="X8307AD6B823FB122" name="X8307AD6B823FB122"></a></p>

<h4>1.4 <span class="Heading">Precompiling categories</span></h4>

<p>The main mode of application of the compiler is precompiling categories and storing the result in a file for later use via <code class="func">CapJitPrecompileCategory</code> (<a href="chap1.html#X81627716853DCE40"><span class="RefLink">1.4-1</span></a>).</p>

<p><a id="X81627716853DCE40" name="X81627716853DCE40"></a></p>

<h5>1.4-1 CapJitPrecompileCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitPrecompileCategory</code>( <var class="Arg">category_constructor</var>, <var class="Arg">given_arguments</var>, <var class="Arg">package_name</var>, <var class="Arg">compiled_category_name</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Compiles operations of the CAP category returned by the function <var class="Arg">category_constructor</var> applied to <var class="Arg">given_arguments</var>. The result is available via a global function called <code class="code">ADD_FUNCTIONS_FOR_</code><var class="Arg">compiled_category_name</var> which is written to the file <var class="Arg">package_name</var><code class="code">/precompiled_categories/</code><var class="Arg">compiled_category_name</var><code class="code">.gi</code> and adds the compiled functions to the category given as the only argument. For testing purposes, there is also a global function called <var class="Arg">compiled_category_name</var> which takes the same arguments as <var class="Arg">category_constructor</var> and returns the category with the compiled functions installed (note: <var class="Arg">category_constructor</var> is called with <code class="code">no_precompiled_code := true</code>, which might lead to uncompiled code being present in lower categories of a tower of categories). If a list of operations is given via the option <code class="code">operations</code>, only operations in this list are precompiled. Else all installed operations (excluding operations which are part of suggested dependencies) of the category are precompiled. Furthermore, the options <code class="code">number_of_objectified_objects_in_data_structure_of_object</code>, <code class="code">number_of_objectified_morphisms_in_data_structure_of_object</code>, <code class="code">number_of_objectified_objects_in_data_structure_of_morphism</code>, and <code class="code">number_of_objectified_morphisms_in_data_structure_of_morphism</code> can optionally be set to allow the compiler to warn about about bad compilation results. For example, <code class="code">number_of_objectified_objects_in_data_structure_of_object</code> should be the number of calls to <code class="code">CreateCapCategoryObjectWithAttributes</code> required for creating an object in the tower defined by <var class="Arg">category_constructor</var>, e.g. 1 if the tower has height one, or 2 if the tower has height two and the objects of the category at the top are given by objects in the category one level below. Warnings will be displayed if this number is exceeded (because this implies that not all wrap-unwrap-pairs could be canceled). Technical requirements:</p>


<ul>
<li><p><var class="Arg">category_constructor</var> must be a regular function, i.e. not an operation or a kernel function.</p>

</li>
<li><p><var class="Arg">category_constructor</var> must support the option <code class="code">FinalizeCategory</code>. WARNING: When using attributes you might run into errors because the options are only respected the first time you call the attribute getter. To catch such a situation, <var class="Arg">category_constructor</var> is applied to <var class="Arg">given_arguments</var> twice and if the results are identical (<code class="code">IsIdenticalObj</code>) an error is raised.</p>

</li>
<li><p>CAP operations returning <code class="code">fail</code> are excluded from the compilation because they usually do not fulfill all requirements of the compiler.</p>

</li>
</ul>
<p><a id="X819343157D62111A" name="X819343157D62111A"></a></p>

<h5>1.4-2 CapJitPrecompileCategoryAndCompareResult</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitPrecompileCategoryAndCompareResult</code>( <var class="Arg">category_constructor</var>, <var class="Arg">given_arguments</var>, <var class="Arg">package_name</var>, <var class="Arg">compiled_category_name</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Calls <code class="func">CapJitPrecompileCategory</code> (<a href="chap1.html#X81627716853DCE40"><span class="RefLink">1.4-1</span></a>) with the given arguments and displays a warning if this changes the contents of <var class="Arg">package_name</var><code class="code">/precompiled_categories/</code><var class="Arg">compiled_category_name</var><code class="code">.gi</code>.</p>

<p><a id="X78F1B59B7DBEF671" name="X78F1B59B7DBEF671"></a></p>

<h4>1.5 <span class="Heading">Compiling a function manually</span></h4>

<p>One can also compile a function <code class="code">func</code> manually via <code class="func">CapJitCompiledFunction</code> (<a href="chap1.html#X86F1D06C81670DC8"><span class="RefLink">1.5-2</span></a>).</p>

<p><a id="X87BAEADB78CC3FF0" name="X87BAEADB78CC3FF0"></a></p>

<h5>1.5-1 CapJitCompiledCAPOperationAsEnhancedSyntaxTree</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitCompiledCAPOperationAsEnhancedSyntaxTree</code>( <var class="Arg">cat</var>, <var class="Arg">operation_name</var>, <var class="Arg">post_processing_enabled</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>A special version of <code class="func">CapJitCompiledFunctionAsEnhancedSyntaxTree</code> (<a href="chap1.html#X7B1445EE85D8CA0A"><span class="RefLink">1.5-3</span></a>) compiling the operation given by <var class="Arg">operation_name</var> in <var class="Arg">cat</var>. The boolean <var class="Arg">post_processing_enabled</var> decides whether the tree before or after post-processing should be returned.</p>

<p><a id="X86F1D06C81670DC8" name="X86F1D06C81670DC8"></a></p>

<h5>1.5-2 CapJitCompiledFunction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitCompiledFunction</code>( <var class="Arg">func</var>[, <var class="Arg">type_signature</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a function</p>

<p>Returns a compiled version of the function <var class="Arg">func</var> with signature <var class="Arg">type_signature</var> (see <code class="func">CapJitInferredDataTypes</code> (<a href="chap2.html#X821BE2CE7C30674E"><span class="RefLink">2.5-10</span></a>)). If <var class="Arg">func</var> is an operation or a kernel function, it is returned unchanged. If <var class="Arg">type_signature</var> is not given, all steps which require knowledge about the types of variables are skipped. If the first argument of <var class="Arg">func</var> is a CAP category, the type signature can also be given by three separate arguments: an instance of a CAP category, a list of input filters (as in <code class="code">filter_list</code> in the method name record) and an output filter (as in <code class="code">return_type</code> in the method name record). If a full type signature is not available but the first argument of <var class="Arg">func</var> is a CAP category, an instance of a CAP category can be given as the second argument. In this case, the category is used to get the type information required to resolve CAP operations.</p>

<p><a id="X7B1445EE85D8CA0A" name="X7B1445EE85D8CA0A"></a></p>

<h5>1.5-3 CapJitCompiledFunctionAsEnhancedSyntaxTree</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitCompiledFunctionAsEnhancedSyntaxTree</code>( <var class="Arg">func</var>, <var class="Arg">post_processing</var>[, <var class="Arg">type_signature</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Returns: a record</p>

<p>Like <code class="func">CapJitCompiledFunction</code> (<a href="chap1.html#X86F1D06C81670DC8"><span class="RefLink">1.5-2</span></a>), but returns an enhanced syntax tree of the compiled function. <var class="Arg">func</var> must not be an operation or a kernel function because those cannot properly be represented as a syntax tree. <var class="Arg">post_processing</var> can be one of the following strings:</p>


<ul>
<li><p><code class="code">"with_post_processing"</code>: The post-processing step, e.g. the application of compiler hints, is executed.</p>

</li>
<li><p><code class="code">"without_post_processing"</code>: The post-processing step is not executed.</p>

</li>
<li><p><code class="code">"with_and_without_post_processing"</code>: A pair of trees is returned: The second tree with post-processing applied, the first tree without.</p>

</li>
</ul>
<p><a id="X7E61259E7D6E8EEB" name="X7E61259E7D6E8EEB"></a></p>

<h4>1.6 <span class="Heading">Giving hints to the compiler</span></h4>

<p>You can give hints to the compiler to improve the result of the compilation. Compiler hints are attached to the category by making <code class="code">category!.compiler_hints</code> a record with one or more of the following keys:</p>


<ul>
<li><p><code class="code">category_attribute_names</code>: a list of names of attributes of the category. If a global variable in the compiled code has the same value (w.r.t. <code class="code">IsIdenticalObj</code>) as one of the given attributes of the category, the global variable is replaced by the attribute getter applied to the category. Background: During the compilation, the compiler resolves attributes occuring in the code and stores them in global variables called <code class="code">CAP_JIT_INTERNAL_GLOBAL_VARIABLE_n</code> (for integers <code class="code">n</code> starting from 1). If these variables cannot be replaced, the resulting code is only valid in the current session.</p>

</li>
<li><p><code class="code">source_and_range_attributes_from_morphism_attribute</code>: a record with keys <code class="code">object_attribute_name</code>, <code class="code">morphism_attribute_name</code>, <code class="code">source_attribute_getter_name</code>, and <code class="code">range_attribute_getter_name</code>. Replaces the attribute <code class="code">object_attribute_name</code> of the source (resp. range) of a morphism by <code class="code">source_attribute_getter_name</code> (resp. <code class="code">range_attribute_getter_name</code>) applied to the attribute <code class="code">morphism_attribute_name</code> of the morphism. Can be used if objects and morphisms can be easily created from the morphism datum anyway. Note: Some simple expressions like integers are NOT replaced.</p>

</li>
</ul>
<p>Note: The compiler can only discover the hints if the category is the first argument of the function.</p>

<p><a id="X7C1A71BB7DC16DDF" name="X7C1A71BB7DC16DDF"></a></p>

<h4>1.7 <span class="Heading">Stopping the compiler at a certain level</span></h4>

<p>You can use <code class="code">StopCompilationAtCategory</code> to prevent the compiler from inlining and optimizing code of a given category. You can revert this decision using <code class="code">ContinueCompilationAtCategory</code>.</p>

<p><a id="X85B3DF4C80406968" name="X85B3DF4C80406968"></a></p>

<h5>1.7-1 StopCompilationAtCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StopCompilationAtCategory</code>( <var class="Arg">category</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Stops the compiler from inlining and optimizing code of <var class="Arg">category</var>.</p>

<p><a id="X7ECBAF2483705ED2" name="X7ECBAF2483705ED2"></a></p>

<h5>1.7-2 ContinueCompilationAtCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ContinueCompilationAtCategory</code>( <var class="Arg">category</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Allows the compiler to inline and optimize code of <var class="Arg">category</var> (this is the default).</p>

<p><a id="X80ABBF057E2687E1" name="X80ABBF057E2687E1"></a></p>

<h5>1.7-3 StopCompilationAtPrimitivelyInstalledOperationsOfCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StopCompilationAtPrimitivelyInstalledOperationsOfCategory</code>( <var class="Arg">category</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Stops the compiler from inlining and optimizing code of primitively installed operations of <var class="Arg">category</var>. Warning: Due to caching of compiled CAP operations, this has to be called before any compilation involving <var class="Arg">category</var>.</p>

<p><a id="X86EE97ED7A87D7CC" name="X86EE97ED7A87D7CC"></a></p>

<h5>1.7-4 ContinueCompilationAtPrimitivelyInstalledOperationsOfCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ContinueCompilationAtPrimitivelyInstalledOperationsOfCategory</code>( <var class="Arg">category</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Allows the compiler to inline and optimize code of primitively installed operations of <var class="Arg">category</var> (this is the default).</p>

<p><a id="X7F76759D7D772538" name="X7F76759D7D772538"></a></p>

<h4>1.8 <span class="Heading">Disabling the automatic inference of data types</span></h4>

<p><a id="X843286607CD2DE7E" name="X843286607CD2DE7E"></a></p>

<h5>1.8-1 CapJitDisableDataTypeInference</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitDisableDataTypeInference</code>(  )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitEnableDataTypeInference</code>(  )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>In case of errors, the automatic inference of data types can be disabled (and re-enabled later on).</p>

<p><a id="X846C79BA815F795A" name="X846C79BA815F795A"></a></p>

<h4>1.9 <span class="Heading">Compiling step-by-step</span></h4>

<p><a id="X7B02F25F82DD0F3A" name="X7B02F25F82DD0F3A"></a></p>

<h5>1.9-1 CapJitEnableStepByStepCompilation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitEnableStepByStepCompilation</code>(  )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitDisableStepByStepCompilation</code>(  )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Enables or disables step-by-step compilation for demonstration or debugging purposes. If enabled, only the first level of CAP operations and known methods is resolved (instead of resolving recursively). Caveats:</p>


<ul>
<li><p>This does not work if fully compiled operations are already cached, so this should be used before starting any compilation.</p>

</li>
<li><p>This does not work if the CAP category is not immediately available from the input (e.g. because it is a range category of a homomorphism structure of the input category).</p>

</li>
</ul>
<p><a id="X8517503D80444503" name="X8517503D80444503"></a></p>

<h4>1.10 <span class="Heading">Proof assistant mode</span></h4>

<p><a id="X795104B985A220EE" name="X795104B985A220EE"></a></p>

<h5>1.10-1 CapJitEnableProofAssistantMode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitEnableProofAssistantMode</code>(  )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitDisableProofAssistantMode</code>(  )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>(experimental) Enables or disables the (experimental) proof assistant mode. For example, in this mode the compiler will display warnings if the code involves CAP operations which are not known to be compatible with the congruence of morphisms, and expressions will not be hoisted or deduplicated.</p>

<p><a id="X7EB255567AF094DA" name="X7EB255567AF094DA"></a></p>

<h5>1.10-2 StateLemma</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StateLemma</code>( <var class="Arg">description</var>, <var class="Arg">claim</var>, <var class="Arg">category</var>, <var class="Arg">filter_strings</var>, <var class="Arg">preconditions</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>(experimental) States a new categorical lemma to be proven in proof assistant mode.</p>


<ul>
<li><p><var class="Arg">description</var> is a human readable version of the statement</p>

</li>
<li><p><var class="Arg">claim</var> is a function formalizing the statement, that is, returning <code class="keyw">true</code> if and only if the statement holds</p>

</li>
<li><p><var class="Arg">category</var> is the category for which the statement shall be proven; the category must be the first argument of <code class="code">claim</code></p>

</li>
<li><p><var class="Arg">filter_strings</var> is a list of filter strings as in the method name record</p>

</li>
<li><p><var class="Arg">preconditions</var> is a list of records of the form <code class="code">rec( src_template := &lt;string&gt;, dst_template := &lt;string&gt; )</code>; the template strings are interpreted in the context of <code class="code">claim</code> and can be used to describe relations between the arguments of <code class="code">claim</code></p>

</li>
</ul>
<p>The aim is to reduce the function <var class="Arg">claim</var> to <code class="code">{...} -&gt; true</code> by applying logic templates via <code class="func">ApplyLogicTemplate</code> (<a href="chap1.html#X808B685A86A2F034"><span class="RefLink">1.10-5</span></a>).</p>

<p><a id="X8434101E7B6EE619" name="X8434101E7B6EE619"></a></p>

<h5>1.10-3 PrintLemma</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PrintLemma</code>(  )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>(experimental) Prints the state of the current lemma.</p>

<p><a id="X81348DC479E3E23A" name="X81348DC479E3E23A"></a></p>

<h5>1.10-4 AttestValidInputs</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AttestValidInputs</code>(  )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>(experimental) Lets the user attest that all arguments in function calls in the state of the current lemma form valid inputs for the functions, for example, that two morphisms passed to <code class="code">PreCompose</code> are actually composable. This allows CompilerForCAP to simplify type checks, for example, that the return value of the call to <code class="code">PreCompose</code> is a well-defined morphism.</p>

<p><a id="X808B685A86A2F034" name="X808B685A86A2F034"></a></p>

<h5>1.10-5 ApplyLogicTemplate</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ApplyLogicTemplate</code>( <var class="Arg">logic_template</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>(experimental) Applies a logic template to the state of the current lemma. If <code class="code">number_of_applications</code> is not set, it defaults to <code class="code">1</code>.</p>

<p><a id="X8474951D8027E03C" name="X8474951D8027E03C"></a></p>

<h5>1.10-6 ApplyLogicTemplateNTimes</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ApplyLogicTemplateNTimes</code>( <var class="Arg">n</var>, <var class="Arg">logic_template</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>(experimental) Applies a logic template <var class="Arg">n</var> times to the state of the current lemma. Note: <code class="code">number_of_applications</code> must not be set.</p>

<p><a id="X8713ECB6806939C0" name="X8713ECB6806939C0"></a></p>

<h5>1.10-7 AssertLemma</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AssertLemma</code>(  )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>(experimental) Asserts that the current lemma is proven, that is, that the state of the current lemma is <code class="code">{...} -&gt; true</code>. If this is the case, the current lemma is cleared, which allows a new lemma to be stated.</p>

<p><a id="X7BA4D059800749B3" name="X7BA4D059800749B3"></a></p>

<h5>1.10-8 StateProposition</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StateProposition</code>( <var class="Arg">category</var>, <var class="Arg">proposition_id</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>(experimental) States a new proposition to be proven for the category <var class="Arg">category</var>. Valid IDs are the entries of <code class="code">RecNames( CAP_JIT_INTERNAL_PROOF_ASSISTANT_PROPOSITIONS )</code>. A proposition is a collection of lemmata which can be stated using <code class="func">StateNextLemma</code> (<a href="chap1.html#X80E20DF57D20BB5B"><span class="RefLink">1.10-9</span></a>) and can then be proven in the same way as a lemma stated using <code class="func">StateLemma</code> (<a href="chap1.html#X7EB255567AF094DA"><span class="RefLink">1.10-2</span></a>).</p>

<p><a id="X80E20DF57D20BB5B" name="X80E20DF57D20BB5B"></a></p>

<h5>1.10-9 StateNextLemma</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StateNextLemma</code>(  )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>(experimental) States the next lemma of the current proposition.</p>

<p><a id="X79477D7D783D70D3" name="X79477D7D783D70D3"></a></p>

<h5>1.10-10 AssertProposition</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AssertProposition</code>(  )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>(experimental) Asserts that the current proposition is proven, that is, that all lemmata of the current proposition are proven.</p>

<p><a id="X7B946AD083F7CEEA" name="X7B946AD083F7CEEA"></a></p>

<h4>1.11 <span class="Heading">Getting information about the compilation process</span></h4>

<p>You can increase the info level of <code class="code">InfoCapJit</code> to get information about the compilation process.</p>

<p><a id="X8202365E84A044DC" name="X8202365E84A044DC"></a></p>

<h5>1.11-1 InfoCapJit</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InfoCapJit</code></td><td class="tdright">(&nbsp;info class&nbsp;)</td></tr></table></div>
<p>Info class used for info messsages of the CAP compiler.</p>

<p><a id="X83CA158B7F828620" name="X83CA158B7F828620"></a></p>

<h5>1.11-2 CapJitSetDebugLevel</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CapJitSetDebugLevel</code>( <var class="Arg">level</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Set the debug level. At level 0, no debug information is printed. At level 1 (or higher), compiled functions are printed at the beginning of the compilation, before the resolving phase, before the rule phase, before the post-processing starts, and at the end of the compilation. At level 2 (or higher), compiled functions are printed after every compilation step. These levels are not fixed and may change in the future.</p>

<p><a id="X780099B481AB3AB7" name="X780099B481AB3AB7"></a></p>

<h4>1.12 <span class="Heading">FAQ</span></h4>


<ul>
<li><p>Q: Where do the category attributes in the compiled code come from?</p>

</li>
</ul>
<p>A: During compilation, attributes of categories are <em>resolved</em>, that is, their values are stored in global variables without keeping track of which category they belong to. After the compilation, CompilerForCAP tries to replace those global variables again by attributes registered via <code class="code">category_attribute_names</code> to the current category (for details, see <a href="chap1.html#X7E61259E7D6E8EEB"><span class="RefLink">1.6</span></a>). If some attributes of the current category are categories themselves, their attributes are also taken into account (recursively). In this case, if two categories <code class="code">cat1</code> and <code class="code">cat2</code> have attributes <code class="code">Attr1</code> and <code class="code">Attr2</code>, respectively, with the same value, it is undefined whether <code class="code">Attr1( cat1 )</code> or <code class="code">Attr2( cat2 )</code> will be used. So even if only <code class="code">Attr2( cat2 )</code> appeared in the original code, <code class="code">Attr1( cat1 )</code> might appear in the compiled code.</p>


<ul>
<li><p>Q: Why is my function not resolved?</p>

</li>
</ul>
<p>A: The function might be listed in <code class="code">CAP_JIT_NON_RESOLVABLE_GLOBAL_VARIABLE_NAMES</code> or it might be missing an annotation with the pragma <code class="code">CAP_JIT_RESOLVE_FUNCTION</code>. Additionally, a function can only be resolved if it appears as a global variable in the tree during the resolving phase of the compilation. That is, it must be referenced from a global variable from the beginning on, or after global variables are resolved by <code class="func">CapJitResolvedGlobalVariables</code> (<a href="chap2.html#X7FD883BA85F7EBE5"><span class="RefLink">2.5-20</span></a>). Possibly you have adapt <code class="func">CapJitResolvedGlobalVariables</code> (<a href="chap2.html#X7FD883BA85F7EBE5"><span class="RefLink">2.5-20</span></a>) to your setting.</p>


<ul>
<li><p>Q: Why is do I get the error "a local variable with name &lt;name&gt; is assigned more than once (not as a part of a rapid reassignment), this is not supported"?</p>

</li>
</ul>
<p>A: For reasons of correctness, variables cannot be inlined if a variable is assigned more than once in the body of a function (this includes function arguments which are assigned at least once, namely when the function is called). An exception is made for "rapid reassignments": if the same variable is assigned and then reassigned immediately in the next statement, this only counts as a single assignment.</p>


<ul>
<li><p>Q: Why do I get one of the following errors: "tree includes statements or expressions which indicate possible side effects", "tree contains an assignment of a higher variable with initial name &lt;name&gt;, this is not supported", or "tree contains for loop over non-local variable, this is not supported" ?</p>

</li>
</ul>
<p>A: We can only drop unused variables, inline variables, etc. if we assume that the code contains no side effects. Statements like STAT_PROCCALL or assignment to higher variables cause (or at least indicate) side effects, so continuing with the compilation would probably not lead to a correct result.</p>


<ul>
<li><p>Q: Why is a given logic function or logic template not applied?</p>

</li>
</ul>
<p>A: There are various possible reasons for this:</p>


<ul>
<li><p>Compiler hints, hoisting, and deduplication are applied after the rule phase, so even if the logic would apply to then final result, it might not apply to the intermediate result.</p>

</li>
<li><p>The compiler might not be able to decide a required equality of expressions because it cannot decide the equality of arbitrary functions.</p>

</li>
<li><p>If the expression is part of a call to <code class="code">CAP_JIT_INCOMPLETE_LOGIC</code>, this shows that it has not fully run through all logic functions/templates.</p>

</li>
</ul>

<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap2.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
