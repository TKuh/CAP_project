<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (FreydCategoriesForCAP) - Chapter 12: Examples and Tests</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap12"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chap14_mj.html">14</a>  <a href="chap15_mj.html">15</a>  <a href="chap16_mj.html">16</a>  <a href="chap17_mj.html">17</a>  <a href="chap18_mj.html">18</a>  <a href="chap19_mj.html">19</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap11_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap13_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap12.html">[MathJax off]</a></p>
<p><a id="X7967FE8E7BBDF485" name="X7967FE8E7BBDF485"></a></p>
<div class="ChapSects"><a href="chap12_mj.html#X7967FE8E7BBDF485">12 <span class="Heading">Examples and Tests</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X8005CEE3800C4F61">12.1 <span class="Heading">Monoidal structure of AdditiveClosure</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X816168F27A34BC10">12.2 <span class="Heading">Adelman category basics for category of rows</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X7F10D27C8668C8FF">12.3 <span class="Heading">Adelman category basics for category of columns</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X800F00FC80F05442">12.4 <span class="Heading">Basics based on category of rows</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X825D413F7D891B06">12.5 <span class="Heading">Basics based on category of columns</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X7C2B2E197863A2B5">12.6 <span class="Heading">CoFreyd category</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X82E68586814D020C">12.7 <span class="Heading">Cokernel image closure in category of rows</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X7FF5A0D086602294">12.8 <span class="Heading">Cokernel image closure in category of columns</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X839428D58152A999">12.9 <span class="Heading">Adelman category basics</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X85F769C5823FAD20">12.10 <span class="Heading">Grade filtration</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X7B34C5EA826BAAAF">12.11 <span class="Heading">Groups as categories</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X7E4FE96D7AD5A312">12.12 <span class="Heading">Homomorphisms between f.p. functors based on category of rows</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X87D4D7857F0B6568">12.13 <span class="Heading">Homomorphisms between f.p. functors based on category of columns</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X86A2AE6E7C297595">12.14 <span class="Heading">Homomorphism structure</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X84C669D87B0599DB">12.15 <span class="Heading">Linear closure of categories</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X81E7031D85FD2569">12.16 <span class="Heading">Matrices over ZP K</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X7F1E3F5A7EC538B6">12.17 <span class="Heading">Matrices over ZG</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X8598E8828771FA9D">12.18 <span class="Heading">Opposite( CategoryOfRow ) as CategoryOfColumns</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X820CD9B28165BF9F">12.19 <span class="Heading">Testing if an object is projective, injective, bijective, and computing projective/injective dimensions</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X7AFC8F247C00D608">12.20 <span class="Heading">Prosets</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X7A810CDA83F2897F">12.21 <span class="Heading">Tests</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X789E61CF843CF960">12.22 <span class="Heading">Category of relations</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap12_mj.html#X8001962586A4466B">12.23 <span class="Heading">Rings as Ab-categories</span></a>
</span>
</div>
</div>

<h3>12 <span class="Heading">Examples and Tests</span></h3>

<p><a id="X8005CEE3800C4F61" name="X8005CEE3800C4F61"></a></p>

<h4>12.1 <span class="Heading">Monoidal structure of AdditiveClosure</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FreydCategoriesForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := RingAsCategory( Q );</span>
RingAsCategory( Q )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A := AdditiveClosure( R );</span>
AdditiveClosure( RingAsCategory( Q ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := TensorUnit( A );</span>
&lt;An object in AdditiveClosure( RingAsCategory( Q ) )\
 defined by 1 underlying objects&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mor1 := [ [ 1 / R, 2 / R ] ] / A;</span>
&lt;A morphism in AdditiveClosure( RingAsCategory( Q ) )\
 defined by a 1 x 2 matrix of underlying morphisms&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mor2 := [ [ 3 / R, 4 / R ] ] / A;</span>
&lt;A morphism in AdditiveClosure( RingAsCategory( Q ) )\
 defined by a 1 x 2 matrix of underlying morphisms&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := TensorProduct( mor1, mor2 );</span>
&lt;A morphism in AdditiveClosure( RingAsCategory( Q ) )\
 defined by a 1 x 4 matrix of underlying morphisms&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( T );</span>
A 1 x 4 matrix with entries in RingAsCategory( Q )

[1,1]: &lt;3&gt;
[1,2]: &lt;4&gt;
[1,3]: &lt;6&gt;
[1,4]: &lt;8&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Range( T ) );</span>
A formal direct sum consisting of 4 objects.
*
*
*
*
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FreydCategoriesForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := TerminalCategoryWithMultipleObjects( );</span>
TerminalCategoryWithMultipleObjects( )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A := "A" / T;</span>
&lt;A zero object in TerminalCategoryWithMultipleObjects( )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := "B" / T;</span>
&lt;A zero object in TerminalCategoryWithMultipleObjects( )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AT := AdditiveClosure( T );</span>
AdditiveClosure( TerminalCategoryWithMultipleObjects( ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ABAA := [ A, B, A, A ] / AT;</span>
&lt;An object in AdditiveClosure( TerminalCategoryWithMultipleObjects( ) )\
 defined by 4 underlying objects&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BAB := [ B, A, B ] / AT;</span>
&lt;An object in AdditiveClosure( TerminalCategoryWithMultipleObjects( ) )\
 defined by 3 underlying objects&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AB := [ A, B ] / AT;</span>
&lt;An object in AdditiveClosure( TerminalCategoryWithMultipleObjects( ) )\
 defined by 2 underlying objects&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mor_AB := MorphismConstructor( A, "A -&gt; B", B );</span>
&lt;A zero, isomorphism in TerminalCategoryWithMultipleObjects( )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mor_BA := MorphismConstructor( B, "B -&gt; A", A );</span>
&lt;A zero, isomorphism in TerminalCategoryWithMultipleObjects( )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id_A := IdentityMorphism( A );</span>
&lt;A zero, identity morphism in TerminalCategoryWithMultipleObjects( )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id_B := IdentityMorphism( B );</span>
&lt;A zero, identity morphism in TerminalCategoryWithMultipleObjects( )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := MorphismConstructor( ABAA,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ [ mor_AB, id_A, mor_AB ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [ id_B, mor_BA, id_B ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [ mor_AB, id_A, mor_AB ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [ mor_AB, id_A, mor_AB ] ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    BAB );</span>
&lt;A morphism in AdditiveClosure( TerminalCategoryWithMultipleObjects( ) )\
 defined by a 4 x 3 matrix of underlying morphisms&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( alpha );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha2 := TensorProduct( alpha, alpha );</span>
&lt;A morphism in AdditiveClosure( TerminalCategoryWithMultipleObjects( ) )\
 defined by a 16 x 9 matrix of underlying morphisms&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( alpha2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphism( alpha2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">left := LeftUnitor( ABAA );</span>
&lt;A morphism in AdditiveClosure( TerminalCategoryWithMultipleObjects( ) )\
 defined by a 4 x 4 matrix of underlying morphisms&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( left );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">left_inv := LeftUnitorInverse( ABAA );</span>
&lt;A morphism in AdditiveClosure( TerminalCategoryWithMultipleObjects( ) )\
 defined by a 4 x 4 matrix of underlying morphisms&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreCompose( left, left_inv ) = IdentityMorphism( Source( left ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreCompose( left_inv, left ) = IdentityMorphism( Range( left ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">right := RightUnitor( BAB );</span>
&lt;A morphism in AdditiveClosure( TerminalCategoryWithMultipleObjects( ) )\
 defined by a 3 x 3 matrix of underlying morphisms&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( right );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">right_inv := RightUnitorInverse( BAB );</span>
&lt;A morphism in AdditiveClosure( TerminalCategoryWithMultipleObjects( ) )\
 defined by a 3 x 3 matrix of underlying morphisms&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreCompose( right, right_inv ) = IdentityMorphism( Source( right ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreCompose( right_inv, right ) = IdentityMorphism( Range( right ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">aslr := AssociatorLeftToRight( AB, BAB, AB );</span>
&lt;A morphism in AdditiveClosure( TerminalCategoryWithMultipleObjects( ) )\
 defined by a 12 x 12 matrix of underlying morphisms&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( aslr );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">asrl := AssociatorRightToLeft( AB, BAB, AB );</span>
&lt;A morphism in AdditiveClosure( TerminalCategoryWithMultipleObjects( ) )\
 defined by a 12 x 12 matrix of underlying morphisms&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreCompose( aslr, asrl ) = IdentityMorphism( Source( aslr ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreCompose( asrl, aslr ) = IdentityMorphism( Range( aslr ) );</span>
true
</pre></div>

<p><a id="X816168F27A34BC10" name="X816168F27A34BC10"></a></p>

<h4>12.2 <span class="Heading">Adelman category basics for category of rows</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := HomalgRingOfIntegers();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rows := CategoryOfRows( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">adelman := AdelmanCategory( rows );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj1 := CategoryOfRowsObject( 1, rows );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj2 := CategoryOfRowsObject( 2, rows );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := CategoryOfRowsMorphism( obj1, HomalgMatrix( [ [ 1, 2 ] ], 1, 2, R ), obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := CategoryOfRowsMorphism( obj2, HomalgMatrix( [ [ 1, 2 ], [ 3, 4 ] ], 2, 2, R ), obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := CategoryOfRowsMorphism( obj2, HomalgMatrix( [ [ 1, 3 ], [ 3, 4 ] ], 2, 2, R ), obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj1_a := AsAdelmanCategoryObject( obj1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj2_a := AsAdelmanCategoryObject( obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := AsAdelmanCategoryMorphism( beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">n := AsAdelmanCategoryMorphism( gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( m );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># backwards compatibility</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">IsIdenticalObj( MorphismDatum( m ), beta );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( m, n ), PreCompose( n, m ) );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( SubtractionForMorphisms( m, m ), ZeroMorphism( obj2_a, obj2_a ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( ZeroObjectFunctorial( adelman ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                         PreCompose( UniversalMorphismFromZeroObject( obj1_a), UniversalMorphismIntoZeroObject( obj1_a ) ) </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d := [ obj1_a, obj2_a ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi1 := ProjectionInFactorOfDirectSum( d, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi2 := ProjectionInFactorOfDirectSum( d, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( DirectSum( d ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iota1 := InjectionOfCofactorOfDirectSum( d, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iota2 := InjectionOfCofactorOfDirectSum( d, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( pi1, iota1 ) + PreCompose( pi2, iota2 ), id );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( UniversalMorphismIntoDirectSum( d, [ pi1, pi2 ] ), id );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( UniversalMorphismFromDirectSum( d, [ iota1, iota2 ] ), id );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := CokernelProjection( m );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c2 := CokernelProjection( c );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( c2, ZeroMorphism( Source( c2 ), Range( c2 ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( CokernelProjection( m ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( CokernelColift( m, CokernelProjection( m ) ), IdentityMorphism( CokernelObject( m ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k := KernelEmbedding( c );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( PreCompose( k, c ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( KernelLift( m, KernelEmbedding( m ) ), IdentityMorphism( KernelObject( m ) ) );</span>
true
</pre></div>

<p><a id="X7F10D27C8668C8FF" name="X7F10D27C8668C8FF"></a></p>

<h4>12.3 <span class="Heading">Adelman category basics for category of columns</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := HomalgRingOfIntegers();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cols := CategoryOfColumns( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">adelman := AdelmanCategory( cols );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj1 := CategoryOfColumnsObject( 1, cols );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj2 := CategoryOfColumnsObject( 2, cols );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := CategoryOfColumnsMorphism( obj1, HomalgMatrix( [ [ 1 ], [ 2 ] ], 2, 1, R ), obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := CategoryOfColumnsMorphism( obj2, HomalgMatrix( [ [ 1, 3 ], [ 2, 4 ] ], 2, 2, R ), obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := CategoryOfColumnsMorphism( obj2, HomalgMatrix( [ [ 1, 3 ], [ 3, 4 ] ], 2, 2, R ), obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj1_a := AsAdelmanCategoryObject( obj1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj2_a := AsAdelmanCategoryObject( obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := AsAdelmanCategoryMorphism( beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">n := AsAdelmanCategoryMorphism( gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( m );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( m, n ), PreCompose( n, m ) );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( SubtractionForMorphisms( m, m ), ZeroMorphism( obj2_a, obj2_a ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( ZeroObjectFunctorial( adelman ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                         PreCompose( UniversalMorphismFromZeroObject( obj1_a), UniversalMorphismIntoZeroObject( obj1_a ) ) </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                        );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d := [ obj1_a, obj2_a ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi1 := ProjectionInFactorOfDirectSum( d, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi2 := ProjectionInFactorOfDirectSum( d, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( DirectSum( d ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iota1 := InjectionOfCofactorOfDirectSum( d, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iota2 := InjectionOfCofactorOfDirectSum( d, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( pi1, iota1 ) + PreCompose( pi2, iota2 ), id );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( UniversalMorphismIntoDirectSum( d, [ pi1, pi2 ] ), id );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( UniversalMorphismFromDirectSum( d, [ iota1, iota2 ] ), id );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := CokernelProjection( m );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c2 := CokernelProjection( c );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( c2, ZeroMorphism( Source( c2 ), Range( c2 ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( CokernelProjection( m ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( CokernelColift( m, CokernelProjection( m ) ), IdentityMorphism( CokernelObject( m ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k := KernelEmbedding( c );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( PreCompose( k, c ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( KernelLift( m, KernelEmbedding( m ) ), IdentityMorphism( KernelObject( m ) ) );</span>
true
</pre></div>

<p><a id="X800F00FC80F05442" name="X800F00FC80F05442"></a></p>

<h4>12.4 <span class="Heading">Basics based on category of rows</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FreydCategoriesForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "RingsForHomalg", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := HomalgRingOfIntegers();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cat := CategoryOfRows( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj1 := CategoryOfRowsObject( 1, cat );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj2 := CategoryOfRowsObject( 2, cat );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphicForObjects( obj1, obj2 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphicForObjects( obj2, obj2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphism( SomeIsomorphismBetweenObjects( obj2, obj2 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := CategoryOfRowsMorphism( obj1, HomalgMatrix( [ [ 1, 2 ] ], 1, 2, R ), obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := CategoryOfRowsMorphism( obj2, HomalgMatrix( [ [ 1, 2 ], [ 3, 4 ] ], 2, 2, R ), obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comp := PreCompose( alpha, beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( comp );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">zero := ZeroMorphism( obj1, obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( zero );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZeroObject( cat );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismIntoZeroObject( obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismFromZeroObject( obj1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    SumOfMorphisms( obj1, [ alpha, alpha, alpha ], obj2 ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    AdditionForMorphisms( alpha, AdditionForMorphisms( alpha, alpha ) )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    SumOfMorphisms( obj1, [ ], obj2 ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ZeroMorphism( obj1, obj2 )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DirectSum( obj1, obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DirectSumFunctorial( [ alpha, beta, id ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">proj := ProjectionInFactorOfDirectSum( [ obj2, obj1, obj2 ], 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( ComponentOfMorphismFromDirectSum( proj, [ obj2, obj1, obj2 ], 1 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOne( ComponentOfMorphismFromDirectSum( proj, [ obj2, obj1, obj2 ], 2 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( ComponentOfMorphismFromDirectSum( proj, [ obj2, obj1, obj2 ], 3 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( ComponentOfMorphismFromCoproduct( proj, [ obj2, obj1, obj2 ], 1 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOne( ComponentOfMorphismFromCoproduct( proj, [ obj2, obj1, obj2 ], 2 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( ComponentOfMorphismFromCoproduct( proj, [ obj2, obj1, obj2 ], 3 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismIntoDirectSum( [ alpha, alpha, alpha ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inj := InjectionOfCofactorOfDirectSum( [ obj2, obj2, obj1 ], 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( ComponentOfMorphismIntoDirectSum( inj, [ obj2, obj2, obj1 ], 1 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOne( ComponentOfMorphismIntoDirectSum( inj, [ obj2, obj2, obj1 ], 2 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( ComponentOfMorphismIntoDirectSum( inj, [ obj2, obj2, obj1 ], 3 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( ComponentOfMorphismIntoDirectProduct( inj, [ obj2, obj2, obj1 ], 1 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOne( ComponentOfMorphismIntoDirectProduct( inj, [ obj2, obj2, obj1 ], 2 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( ComponentOfMorphismIntoDirectProduct( inj, [ obj2, obj2, obj1 ], 3 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := CategoryOfRowsMorphism( obj2, HomalgMatrix( [ [ 1, 1 ], [ 1, 1 ] ], 2, 2, R ), obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsColiftable( beta, gamma );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsColiftable( gamma, beta );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProjectionInFirstFactorOfWeakBiFiberProduct( gamma, gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProjectionInFirstFactorOfWeakBiFiberProduct( gamma, ZeroMorphism( Range( gamma ), Range( gamma ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lift_arg_1 := PreCompose( ProjectionInFirstFactorOfWeakBiFiberProduct( gamma, gamma + gamma ), gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lift_arg_2 := gamma + gamma;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLiftable( lift_arg_1, lift_arg_2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lift( lift_arg_1, lift_arg_2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi1 := ProjectionInFirstFactorOfWeakBiFiberProduct( alpha, beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi2 := ProjectionInSecondFactorOfWeakBiFiberProduct( alpha, beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForMorphisms( PreCompose( pi1, alpha ), PreCompose( pi2, beta ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inj1 := InjectionOfFirstCofactorOfWeakBiPushout( gamma + gamma, gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inj2 := InjectionOfSecondCofactorOfWeakBiPushout( gamma + gamma, gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForMorphisms( PreCompose( gamma + gamma, inj1 ), PreCompose( gamma, inj2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">WeakKernelLift( WeakCokernelProjection( gamma ), gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi1 := InjectionOfFirstCofactorOfWeakBiPushout( alpha, alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi2 := InjectionOfSecondCofactorOfWeakBiPushout( alpha, alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismFromWeakBiPushout( alpha, alpha, pi1, pi2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## Freyd categories</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">freyd := FreydCategory( cat );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAbelianCategory( freyd );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj_gamma := FreydCategoryObject( gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := RandomMorphismWithFixedSource( obj_gamma, [ [5], [5] ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( u ) and IsEqualForObjects( Source(u), obj_gamma );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := RandomMorphismWithFixedSource( obj_gamma, 5 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( u ) and IsEqualForObjects( Source(u), obj_gamma );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := RandomMorphismWithFixedRange( obj_gamma, [ [5], [5] ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( u ) and IsEqualForObjects( Range(u), obj_gamma );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := RandomMorphismWithFixedRange( obj_gamma, 5 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( u ) and IsEqualForObjects( Range(u), obj_gamma );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj_delta := RandomObject( freyd, [[10],[10],[10]] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj_delta := RandomObject( freyd, 10 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := RandomMorphismWithFixedSourceAndRange( obj_gamma, obj_delta, [ 5 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( u );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForObjects( Source(u), obj_gamma ) and IsEqualForObjects( Range(u), obj_delta );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := RandomMorphismWithFixedSourceAndRange( obj_gamma, obj_delta, 5 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( u );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForObjects( Source(u), obj_gamma ) and IsEqualForObjects( Range(u), obj_delta );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( RandomMorphism( freyd, 5 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( RandomMorphism( freyd, [[[5],[5],[5]],[[5],[5],[5]],[1]] ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := FreydCategoryMorphism( obj_gamma, gamma, obj_gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">witness := MorphismWitness( f );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := FreydCategoryMorphism( obj_gamma, ZeroMorphism( obj2, obj2 ), obj_gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( f, g );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := PreCompose( f, f );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s := g + g;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := CategoryOfRowsMorphism( obj1, HomalgMatrix( [ [ 2 ] ], 1, 1, R ), obj1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Z2 := FreydCategoryObject( a );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( Z2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z := id + id + id;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d := DirectSumFunctorial( [ z, z, z ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pr2 := ProjectionInFactorOfDirectSum( [ Z2, Z2, Z2 ], 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pr3 := ProjectionInFactorOfDirectSum( [ Z2, Z2, Z2 ], 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismIntoDirectSum( [ pr3, pr2 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inj1 := InjectionOfCofactorOfDirectSum( [ Z2, Z2, Z2 ], 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inj2 := InjectionOfCofactorOfDirectSum( [ Z2, Z2, Z2 ], 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismFromDirectSum( [ inj2, inj1 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZFree := obj1/freyd;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( ZFree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z := id + id;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CokernelProjection( z );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CokernelColift( z, CokernelProjection( z ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismFromZeroObjectWithGivenZeroObject( obj_gamma, ZeroObject( freyd ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MultiplyWithElementOfCommutativeRingForMorphisms( 2 / R, f );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := HomalgFieldOfRationalsInSingular() * "x,y,z";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Rows_S := CategoryOfRows( S );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S3 := CategoryOfRowsObject( 3, Rows_S );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S1 := CategoryOfRowsObject( 1, Rows_S );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mor := CategoryOfRowsMorphism( S3, HomalgMatrix( "[x,y,z]", 3, 1, S ), S1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">biased_w := CategoryOfRowsMorphism( S3, HomalgMatrix( "[x,0,0,0,x,0,0,0,x]", 3, 3, S ), S3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">biased_h := CategoryOfRowsMorphism( S3, HomalgMatrix( "[x*y, x*z, y^2]", 3, 3, S ), S3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BiasedWeakFiberProduct( biased_h, biased_w );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProjectionOfBiasedWeakFiberProduct( biased_h, biased_w );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   PreCompose( UniversalMorphismIntoBiasedWeakFiberProduct( biased_h, biased_w, biased_h ), ProjectionOfBiasedWeakFiberProduct( biased_h, biased_w ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   biased_h</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  PreCompose( InjectionOfBiasedWeakPushout( biased_h, biased_w ), UniversalMorphismFromBiasedWeakPushout( biased_h, biased_w, biased_h )),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  biased_h</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k := FreydCategoryObject( mor );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w := EpimorphismFromSomeProjectiveObjectForKernelObject( UniversalMorphismIntoZeroObject( k ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k := KernelEmbedding( w );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ColiftAlongEpimorphism( CokernelProjection( k ), CokernelProjection( k ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## Homomorphism structures</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">a := InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( Source( a ), Range( a ), InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( a ) ), a );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := ZeroObjectFunctorial( cat );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( Source( a ), Range( a ), InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( a ) ), a );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Z4 := FreydCategoryObject( AsCategoryOfRowsMorphism( HomalgMatrix( "[4]", 1, 1, R ), cat ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Z3 := FreydCategoryObject( AsCategoryOfRowsMorphism( HomalgMatrix( "[3]", 1, 1, R ), cat ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismStructureOnObjects( Z4, Z2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismStructureOnObjects( Z4, Z4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismStructureOnObjects( Z2, Z4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismStructureOnObjects( Z3, Z4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismStructureOnMorphisms( IdentityMorphism( DirectSum( Z4, Z2, Z3 ) ), -IdentityMorphism( DirectSum( Z4, Z3 ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## Lifts</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">S2 := CategoryOfRowsObject( 2, Rows_S );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S4 := CategoryOfRowsObject( 4, Rows_S );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S1_freyd := AsFreydCategoryObject( S1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S2_freyd := AsFreydCategoryObject( S2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S3_freyd := AsFreydCategoryObject( S3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S4_freyd := AsFreydCategoryObject( S4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lift := FreydCategoryMorphism( S1_freyd, CategoryOfRowsMorphism( S1, HomalgMatrix( "[x]", 1, 1, S ), S1 ), S1_freyd );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := FreydCategoryMorphism( S1_freyd, CategoryOfRowsMorphism( S1, HomalgMatrix( "[y]", 1,1, S ), S1 ), S1_freyd );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := PreCompose( lift, gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLiftable( alpha, gamma );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lift( alpha, gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsColiftable( lift, alpha );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( lift, Colift( lift, alpha ) ), alpha );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lift := FreydCategoryMorphism( S2_freyd, CategoryOfRowsMorphism( S2, HomalgMatrix( "[x,y,z,x^2,1,z+1]", 2, 3, S ), S3 ), S3_freyd );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := FreydCategoryMorphism( S3_freyd, CategoryOfRowsMorphism( S3, HomalgMatrix( "[x,y,z,z+1, x^2,y^2,z^2,z^2+1, x^3,y^3,z^3,z^3+1]", 3,4, S ), S4 ), S4_freyd );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := PreCompose( lift, gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lift( alpha, gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Colift( lift, alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( lift, Colift( lift, alpha ) ), alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">interpretation := InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( gamma,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( Source( gamma ), Range( gamma ), interpretation ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## Opposite</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">HomomorphismStructureOnObjects( Opposite( Z4 ), Opposite( Z2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismStructureOnObjects( Z2, Z4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">interpretation := InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( Opposite( gamma ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( Opposite( gamma ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( Source( Opposite( gamma ) ), Range( Opposite( gamma ) ), interpretation ) );</span>
true
</pre></div>

<p><a id="X825D413F7D891B06" name="X825D413F7D891B06"></a></p>

<h4>12.5 <span class="Heading">Basics based on category of columns</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := HomalgRingOfIntegers();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cat := CategoryOfColumns( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj1 := CategoryOfColumnsObject( 1, cat );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj2 := CategoryOfColumnsObject( 2, cat );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := CategoryOfColumnsMorphism( obj1, HomalgMatrix( [ [ 1 ], [ 2 ] ], 1, 2, R ), obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := CategoryOfColumnsMorphism( obj2, HomalgMatrix( [ [ 1, 2 ], [ 3, 4 ] ], 2, 2, R ), obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comp := PreCompose( alpha, beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( comp );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">zero := ZeroMorphism( obj1, obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( zero );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZeroObject( cat );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismIntoZeroObject( obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismFromZeroObject( obj1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DirectSum( obj1, obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DirectSumFunctorial( [ alpha, beta, id ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">proj := ProjectionInFactorOfDirectSum( [ obj2, obj1, obj2 ], 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( ComponentOfMorphismFromDirectSum( proj, [ obj2, obj1, obj2 ], 1 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOne( ComponentOfMorphismFromDirectSum( proj, [ obj2, obj1, obj2 ], 2 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( ComponentOfMorphismFromDirectSum( proj, [ obj2, obj1, obj2 ], 3 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismIntoDirectSum( [ alpha, alpha, alpha ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inj := InjectionOfCofactorOfDirectSum( [ obj2, obj2, obj1 ], 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( ComponentOfMorphismIntoDirectSum( inj, [ obj2, obj2, obj1 ], 1 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOne( ComponentOfMorphismIntoDirectSum( inj, [ obj2, obj2, obj1 ], 2 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( ComponentOfMorphismIntoDirectSum( inj, [ obj2, obj2, obj1 ], 3 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := CategoryOfColumnsMorphism( obj2, HomalgMatrix( [ [ 1, 1 ], [ 1, 1 ] ], 2, 2, R ), obj2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsColiftable( beta, gamma );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsColiftable( gamma, beta );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProjectionInFirstFactorOfWeakBiFiberProduct( gamma, gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProjectionInFirstFactorOfWeakBiFiberProduct( gamma, ZeroMorphism( Range( gamma ), Range( gamma ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lift_arg_1 := PreCompose( ProjectionInFirstFactorOfWeakBiFiberProduct( gamma, gamma + gamma ), gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lift_arg_2 := gamma + gamma;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLiftable( lift_arg_1, lift_arg_2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lift( lift_arg_1, lift_arg_2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi1 := ProjectionInFirstFactorOfWeakBiFiberProduct( alpha, beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi2 := ProjectionInSecondFactorOfWeakBiFiberProduct( alpha, beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForMorphisms( PreCompose( pi1, alpha ), PreCompose( pi2, beta ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inj1 := InjectionOfFirstCofactorOfWeakBiPushout( gamma + gamma, gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inj2 := InjectionOfSecondCofactorOfWeakBiPushout( gamma + gamma, gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForMorphisms( PreCompose( gamma + gamma, inj1 ), PreCompose( gamma, inj2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">WeakKernelLift( WeakCokernelProjection( gamma ), gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi1 := InjectionOfFirstCofactorOfWeakBiPushout( alpha, alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi2 := InjectionOfSecondCofactorOfWeakBiPushout( alpha, alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismFromWeakBiPushout( alpha, alpha, pi1, pi2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## Freyd categories</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">freyd := FreydCategory( cat );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAbelianCategory( freyd );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj_gamma := FreydCategoryObject( gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := FreydCategoryMorphism( obj_gamma, gamma, obj_gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">witness := MorphismWitness( f );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := FreydCategoryMorphism( obj_gamma, ZeroMorphism( obj2, obj2 ), obj_gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( f, g );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := PreCompose( f, f );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s := g + g;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := CategoryOfColumnsMorphism( obj1, HomalgMatrix( [ [ 2 ] ], 1, 1, R ), obj1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Z2 := FreydCategoryObject( a );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( Z2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z := id + id + id;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d := DirectSumFunctorial( [ z, z, z ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pr2 := ProjectionInFactorOfDirectSum( [ Z2, Z2, Z2 ], 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pr3 := ProjectionInFactorOfDirectSum( [ Z2, Z2, Z2 ], 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismIntoDirectSum( [ pr3, pr2 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inj1 := InjectionOfCofactorOfDirectSum( [ Z2, Z2, Z2 ], 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inj2 := InjectionOfCofactorOfDirectSum( [ Z2, Z2, Z2 ], 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismFromDirectSum( [ inj2, inj1 ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZFree := AsFreydCategoryObject( obj1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( ZFree );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z := id + id;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CokernelProjection( z );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CokernelColift( z, CokernelProjection( z ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := HomalgFieldOfRationalsInSingular() * "x,y,z";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Cols_S := CategoryOfColumns( S );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S3 := CategoryOfColumnsObject( 3, Cols_S );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S1 := CategoryOfColumnsObject( 1, Cols_S );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mor := CategoryOfColumnsMorphism( S3, HomalgMatrix( "[x,y,z]", 1, 3, S ), S1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">biased_w := CategoryOfColumnsMorphism( S3, HomalgMatrix( "[x,0,0,0,x,0,0,0,x]", 3, 3, S ), S3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">biased_h := CategoryOfColumnsMorphism( S3, HomalgMatrix( "[x*y, x*z, y^2]", 3, 3, S ), S3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BiasedWeakFiberProduct( biased_h, biased_w );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProjectionOfBiasedWeakFiberProduct( biased_h, biased_w );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   PreCompose( UniversalMorphismIntoBiasedWeakFiberProduct( biased_h, biased_w, biased_h ), ProjectionOfBiasedWeakFiberProduct( biased_h, biased_w ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   biased_h</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  PreCompose( InjectionOfBiasedWeakPushout( biased_h, biased_w ), UniversalMorphismFromBiasedWeakPushout( biased_h, biased_w, biased_h )),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  biased_h</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k := FreydCategoryObject( mor );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w := EpimorphismFromSomeProjectiveObjectForKernelObject( UniversalMorphismIntoZeroObject( k ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k := KernelEmbedding( w );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ColiftAlongEpimorphism( CokernelProjection( k ), CokernelProjection( k ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## Homomorphism structures</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">a := InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( Source( a ), Range( a ), InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( a ) ), a );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := ZeroObjectFunctorial( cat );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( Source( a ), Range( a ), InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( a ) ), a );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Z4 := FreydCategoryObject( AsCategoryOfColumnsMorphism( HomalgMatrix( "[4]", 1, 1, R ), cat ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Z3 := FreydCategoryObject( AsCategoryOfColumnsMorphism( HomalgMatrix( "[3]", 1, 1, R ), cat ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismStructureOnObjects( Z4, Z2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismStructureOnObjects( Z4, Z4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismStructureOnObjects( Z2, Z4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismStructureOnObjects( Z3, Z4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismStructureOnMorphisms( IdentityMorphism( DirectSum( Z4, Z2, Z3 ) ), -IdentityMorphism( DirectSum( Z4, Z3 ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## Lifts</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">S2 := CategoryOfColumnsObject( 2, Cols_S );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S4 := CategoryOfColumnsObject( 4, Cols_S );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S1_freyd := AsFreydCategoryObject( S1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S2_freyd := AsFreydCategoryObject( S2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S3_freyd := AsFreydCategoryObject( S3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S4_freyd := AsFreydCategoryObject( S4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lift := FreydCategoryMorphism( S1_freyd, CategoryOfColumnsMorphism( S1, HomalgMatrix( "[x]", 1, 1, S ), S1 ), S1_freyd );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := FreydCategoryMorphism( S1_freyd, CategoryOfColumnsMorphism( S1, HomalgMatrix( "[y]", 1,1, S ), S1 ), S1_freyd );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := PreCompose( lift, gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lift( alpha, gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Colift( lift, alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( lift, Colift( lift, alpha ) ), alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lift := FreydCategoryMorphism( S2_freyd, CategoryOfColumnsMorphism( S2, HomalgMatrix( "[x,y,z,x^2,1,z+1]", 3, 2, S ), S3 ), S3_freyd );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := FreydCategoryMorphism( S3_freyd, CategoryOfColumnsMorphism( S3, HomalgMatrix( "[x,y,z,z+1, x^2,y^2,z^2,z^2+1, x^3,y^3,z^3,z^3+1]", 4,3, S ), S4 ), S4_freyd );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := PreCompose( lift, gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lift( alpha, gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Colift( lift, alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( lift, Colift( lift, alpha ) ), alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">interpretation := InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( gamma );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( gamma,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( Source( gamma ), Range( gamma ), interpretation ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## Opposite</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">HomomorphismStructureOnObjects( Opposite( Z4 ), Opposite( Z2 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomomorphismStructureOnObjects( Z2, Z4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">interpretation := InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( Opposite( gamma ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( Opposite( gamma ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( Source( Opposite( gamma ) ), Range( Opposite( gamma ) ), interpretation ) );</span>
true
</pre></div>

<p><a id="X7C2B2E197863A2B5" name="X7C2B2E197863A2B5"></a></p>

<h4>12.6 <span class="Heading">CoFreyd category</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FreydCategoriesForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZZZ := HomalgRingOfIntegers( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rows := CategoryOfRows( ZZZ );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">co_freyd := CoFreydCategory( rows );</span>
CoFreyd( Rows( Z ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rows_obj := CategoryOfRowsObject( rows, 1 );; # ZZZ^1</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">co_freyd_obj := AsCoFreydCategoryObject( rows_obj );; # ZZZ^1 -&gt; 0</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rows_mor := CategoryOfRowsMorphism( rows, rows_obj, HomalgMatrix( [ 2 ], 1, 1, ZZZ ), rows_obj );; # ZZZ^1 --2-&gt; ZZZ^1</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">co_freyd_mor := CoFreydCategoryMorphism( co_freyd_obj, rows_mor, co_freyd_obj );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( co_freyd_mor );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( KernelObject( co_freyd_mor ) );</span>

--------------------------------
CoRelation morphism:
--------------------------------

Source: 
A row module over Z of rank 1

Matrix: 
[ [  2 ] ]

Range: 
A row module over Z of rank 1

A morphism in Rows( Z )


--------------------------------
General description:
--------------------------------

An object in CoFreyd( Rows( Z ) )

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingMorphism( KernelEmbedding( co_freyd_mor ) ) );</span>
Source: 
A row module over Z of rank 1

Matrix: 
[ [  1 ] ]

Range: 
A row module over Z of rank 1

An identity morphism in Rows( Z )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( CokernelObject( co_freyd_mor ) );</span>

--------------------------------
CoRelation morphism:
--------------------------------

Source: 
A row module over Z of rank 0

Matrix: 
(an empty 0 x 0 matrix)

Range: 
A row module over Z of rank 0

A morphism in Rows( Z )


--------------------------------
General description:
--------------------------------

An object in CoFreyd( Rows( Z ) )

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( UnderlyingMorphism( CokernelProjection( co_freyd_mor ) ) );</span>
Source: 
A row module over Z of rank 1

Matrix: 
(an empty 1 x 0 matrix)

Range: 
A row module over Z of rank 0

A morphism in Rows( Z )
</pre></div>

<p><a id="X82E68586814D020C" name="X82E68586814D020C"></a></p>

<h4>12.7 <span class="Heading">Cokernel image closure in category of rows</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := HomalgFieldOfRationalsInSingular() * "x,y,z";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RowsR := CategoryOfRows( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := AsCategoryOfRowsMorphism( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    HomalgMatrix( "[[x],[y],[z]]", 3, 1, R ), RowsR</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mu := AsCokernelImageClosureMorphism( m );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CokernelObject( mu );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C2 := AsFinitelyPresentedCokernelImageClosureObject( m );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForObjects( C, C2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">n := AsCategoryOfRowsMorphism( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    HomalgMatrix( "[[x,y],[y^2,z]]", 2, 2, R ), RowsR</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nu := AsCokernelImageClosureMorphism( n );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nu2 := PreCompose( nu, nu );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( nu2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( nu, nu2 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nu + nu;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nu2 - nu;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cat := CapCategory( nu );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZeroObject( cat );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZeroMorphism( Source( nu ), Source( mu ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismIntoZeroObject( Source( nu ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismFromZeroObject( Source( nu ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Source( mu );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DirectSum( [S, S, S ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DirectSumFunctorial( [ nu2, nu ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismIntoDirectSum( [ nu, nu ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismFromDirectSum( [ nu, nu ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProjectionInFactorOfDirectSum( [ S, S, S ], 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InjectionOfCofactorOfDirectSum( [ S, S, S, S ], 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CokernelColift( nu, CokernelProjection( nu ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( nu, PreCompose( CoastrictionToImage( nu ), ImageEmbedding( nu ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := UniversalMorphismFromImage( nu, [ nu, IdentityMorphism( Range( nu ) ) ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( u );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( nu, PreCompose( CoastrictionToImage( nu ), u ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( u, ImageEmbedding( nu ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">kernel := KernelObject( mu );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">emb := KernelEmbedding( mu );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := PreCompose( EpimorphismFromSomeProjectiveObject( kernel ), KernelEmbedding( mu ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KernelLift( mu, p );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LiftAlongMonomorphism( emb, p );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">I_to_A := FunctorCokernelImageClosureToFreydCategory( RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A_to_I := FunctorFreydCategoryToCokernelImageClosure( RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( I_to_A, kernel );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( A_to_I, ApplyFunctor( I_to_A, kernel ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nu := NaturalIsomorphismFromIdentityToFinitePresentationOfCokernelImageClosureObject( RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mu := NaturalIsomorphismFromFinitePresentationOfCokernelImageClosureObjectToIdentity( RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    IdentityMorphism( kernel ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    PreCompose( ApplyNaturalTransformation( nu, kernel ), ApplyNaturalTransformation( mu, kernel ) )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);</span>
true
</pre></div>

<p><a id="X7FF5A0D086602294" name="X7FF5A0D086602294"></a></p>

<h4>12.8 <span class="Heading">Cokernel image closure in category of columns</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := HomalgFieldOfRationalsInSingular() * "x,y,z";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ColsR := CategoryOfColumns( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := AsCategoryOfColumnsMorphism( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     HomalgMatrix( "[[x],[y],[z]]", 1, 3, R ), ColsR</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mu := AsCokernelImageClosureMorphism( m );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CokernelObject( mu );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C2 := AsFinitelyPresentedCokernelImageClosureObject( m );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForObjects( C, C2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">n := AsCategoryOfColumnsMorphism( </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    HomalgMatrix( "[[x,y],[y^2,z]]", 2, 2, R ), ColsR</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nu := AsCokernelImageClosureMorphism( n );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nu2 := PreCompose( nu, nu );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( nu2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( nu, nu2 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nu + nu;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nu2 - nu;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cat := CapCategory( nu );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZeroObject( cat );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZeroMorphism( Source( nu ), Source( mu ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismIntoZeroObject( Source( nu ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismFromZeroObject( Source( nu ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S := Source( mu );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DirectSum( [S, S, S ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DirectSumFunctorial( [ nu2, nu ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismIntoDirectSum( [ nu, nu ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">UniversalMorphismFromDirectSum( [ nu, nu ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProjectionInFactorOfDirectSum( [ S, S, S ], 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InjectionOfCofactorOfDirectSum( [ S, S, S, S ], 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CokernelColift( nu, CokernelProjection( nu ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( nu, PreCompose( CoastrictionToImage( nu ), ImageEmbedding( nu ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := UniversalMorphismFromImage( nu, [ nu, IdentityMorphism( Range( nu ) ) ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( u );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( nu, PreCompose( CoastrictionToImage( nu ), u ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( u, ImageEmbedding( nu ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">kernel := KernelObject( mu );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">emb := KernelEmbedding( mu );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := PreCompose( EpimorphismFromSomeProjectiveObject( kernel ), KernelEmbedding( mu ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KernelLift( mu, p );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LiftAlongMonomorphism( emb, p );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">I_to_A := FunctorCokernelImageClosureToFreydCategory( ColsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A_to_I := FunctorFreydCategoryToCokernelImageClosure( ColsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( I_to_A, kernel );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( A_to_I, ApplyFunctor( I_to_A, kernel ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nu := NaturalIsomorphismFromIdentityToFinitePresentationOfCokernelImageClosureObject( ColsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mu := NaturalIsomorphismFromFinitePresentationOfCokernelImageClosureObjectToIdentity( ColsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    IdentityMorphism( kernel ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    PreCompose( ApplyNaturalTransformation( nu, kernel ), ApplyNaturalTransformation( mu, kernel ) )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);</span>
true
</pre></div>

<p><a id="X839428D58152A999" name="X839428D58152A999"></a></p>

<h4>12.9 <span class="Heading">Adelman category basics</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := HomalgRingOfIntegers();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RowsR := CategoryOfRows( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">one := AsCategoryOfRowsMorphism( HomalgMatrix( [ [ 1 ] ], 1, 1, R ), RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">two := AsCategoryOfRowsMorphism( HomalgMatrix( [ [ 2 ] ], 1, 1, R ), RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">four := AsCategoryOfRowsMorphism( HomalgMatrix( [ [ 4 ] ], 1, 1, R ), RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">source := AdelmanCategoryObject( two, two );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">range := AdelmanCategoryObject( two, four );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mor := AdelmanCategoryMorphism( source, one, range );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( mor );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">emb := EmbeddingFunctorIntoFreydCategory( RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ind := AdelmanCategoryFunctorInducedByUniversalProperty( emb );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( ApplyFunctor( ind, mor ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := FreydCategoryObject( AsCategoryOfRowsMorphism( HomalgMatrix( [ [  2, 2, 2 ], [ 4, 4, 6 ] ], 2, 3, R ), RowsR ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">as_tensor := EmbeddingFunctorOfFreydCategoryIntoAdelmanCategory( RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Mt := ApplyFunctor( as_tensor, M );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lsat := LeftSatelliteAsEndofunctorOfAdelmanCategory( RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rsat := RightSatelliteAsEndofunctorOfAdelmanCategory( RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">torsion := ApplyFunctor( ind, ( ApplyFunctor( rsat, ApplyFunctor( lsat, Mt ) ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">unit := UnitOfSatelliteAdjunctionOfAdelmanCategory( RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( ApplyNaturalTransformation( unit, Mt ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">counit := CounitOfSatelliteAdjunctionOfAdelmanCategory( RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t := ApplyNaturalTransformation( counit, Mt );;</span>
</pre></div>

<p><a id="X85F769C5823FAD20" name="X85F769C5823FAD20"></a></p>

<h4>12.10 <span class="Heading">Grade filtration</span></h4>

<p>The sequence of modules computed via satellites behaves in a way that is not understood in the case when the ring is not Auslander regular.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := HomalgFieldOfRationalsInSingular() * "x,y";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := R/"x*y"/"x^2";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RowsR := CategoryOfRows( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Freyd := FreydCategory( RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := HomalgMatrix( "[x,y]", 1, 2, R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := mat/Freyd;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mu1 := GradeFiltrationNthMonomorphism( M, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( mu1 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( mu1 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEpimorphism( mu1 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mu2 := GradeFiltrationNthMonomorphism( M, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphism( mu2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( mu2 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mu3 := GradeFiltrationNthMonomorphism( M, 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphism( mu3 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( mu3 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mu4 := GradeFiltrationNthMonomorphism( M, 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( mu4 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEpimorphism( mu4 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( mu4 );</span>
false
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Qxyz := HomalgFieldOfRationalsInDefaultCAS( ) * "x,y,z";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">wmat := HomalgMatrix( "[ \</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">x*y,  y*z,    z,        0,         0,    \</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">x^3*z,x^2*z^2,0,        x*z^2,     -z^2, \</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">x^4,  x^3*z,  0,        x^2*z,     -x*z, \</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">0,    0,      x*y,      -y^2,      x^2-1,\</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">0,    0,      x^2*z,    -x*y*z,    y*z,  \</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">0,    0,      x^2*y-x^2,-x*y^2+x*y,y^2-y \</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">]", 6, 5, Qxyz );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RowsR := CategoryOfRows( Qxyz );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Freyd := FreydCategory( RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Adel := AdelmanCategory( RowsR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := wmat/Freyd;;</span>
</pre></div>

<p>We compute the grade sequence of functors (it turns out that on the level of functors, we don't get monos)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M_tor := M/Adel;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Mu1 := GradeFiltrationNthNaturalTransformationComponent( M_tor, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( Mu1 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( Mu1 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Mu2 := GradeFiltrationNthNaturalTransformationComponent( M_tor, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( Mu2 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( Mu2 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Mu3 := GradeFiltrationNthNaturalTransformationComponent( M_tor, 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( Mu3 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( Mu3 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Mu4 := GradeFiltrationNthNaturalTransformationComponent( M_tor, 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( Mu4 );</span>
true
</pre></div>

<p>We compute the grade sequence of modules (here, we really get monos and thus a filtration)</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mu1 := GradeFiltrationNthMonomorphism( M, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( mu1 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( mu1 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mu2 := GradeFiltrationNthMonomorphism( M, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( mu2 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( mu2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mu3 := GradeFiltrationNthMonomorphism( M, 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( mu3 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsMonomorphism( mu3 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mu4 := GradeFiltrationNthMonomorphism( M, 4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( mu4 );</span>
true
</pre></div>

<p><a id="X7B34C5EA826BAAAF" name="X7B34C5EA826BAAAF"></a></p>

<h4>12.11 <span class="Heading">Groups as categories</span></h4>


<div class="example"><pre>
#@if IsPackageMarkedForLoading( "FinSetsForCAP", "&gt;= 2023.07-03" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SymmetricGroup( 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CG := GroupAsCategory( G );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := GroupAsCategoryUniqueObject( CG );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfObjectsOfCategory( CG ) = [ u ];</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( SetOfMorphismsOfFiniteCategory( CG ) ) = Size( G );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := GroupAsCategoryMorphism( (1,2,3), CG );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha * Inverse( alpha ) = IdentityMorphism( u );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := GroupAsCategoryMorphism( (1,2,3,5), CG );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( beta );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := GroupAsCategoryMorphism( (1,3), CG );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( gamma );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lift( alpha, gamma ) * gamma = alpha;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha * Colift( alpha, gamma ) = gamma;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( HomomorphismStructureOnObjects( u, u ) ) = Size( G );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    u,u,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    PreCompose(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( alpha ), HomomorphismStructureOnMorphisms( gamma, Inverse( gamma ) )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">=</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">gamma * alpha * Inverse( gamma );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x := (2,3)/CG;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := ()/CG;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIdenticalObj( x * x, id );</span>
true
#@fi
</pre></div>

<p><a id="X7E4FE96D7AD5A312" name="X7E4FE96D7AD5A312"></a></p>

<h4>12.12 <span class="Heading">Homomorphisms between f.p. functors based on category of rows</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := HomalgFieldOfRationalsInSingular() * "x,y,z";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Rows_R := CategoryOfRows( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R1 := CategoryOfRowsObject( 1, Rows_R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R3 := CategoryOfRowsObject( 3, Rows_R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := CategoryOfRowsMorphism( R3, HomalgMatrix( "[x,y,z]", 3, 1, R ), R1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := FreydCategoryObject( alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c0 := CovariantExtAsFreydCategoryObject( M, 0 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c1 := CovariantExtAsFreydCategoryObject( M, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c2 := CovariantExtAsFreydCategoryObject( M, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForObjects( HomomorphismStructureOnObjects( c0, c2 ) ); # = Ext^2( M, M )</span>
false
</pre></div>

<p><a id="X87D4D7857F0B6568" name="X87D4D7857F0B6568"></a></p>

<h4>12.13 <span class="Heading">Homomorphisms between f.p. functors based on category of columns</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := HomalgFieldOfRationalsInSingular() * "x,y,z";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Cols_R := CategoryOfColumns( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R1 := CategoryOfColumnsObject( 1, Cols_R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R3 := CategoryOfColumnsObject( 3, Cols_R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := CategoryOfColumnsMorphism( R3, HomalgMatrix( "[x,y,z]", 1, 3, R ), R1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := FreydCategoryObject( alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c0 := CovariantExtAsFreydCategoryObject( M, 0 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c1 := CovariantExtAsFreydCategoryObject( M, 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c2 := CovariantExtAsFreydCategoryObject( M, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForObjects( HomomorphismStructureOnObjects( c0, c2 ) ); # = Ext^2( M, M )</span>
false
</pre></div>

<p><a id="X86A2AE6E7C297595" name="X86A2AE6E7C297595"></a></p>

<h4>12.14 <span class="Heading">Homomorphism structure</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FreydCategoriesForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "RingsForHomalg", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EEE := KoszulDualRing( HomalgFieldOfRationalsInSingular( ) * "x,y" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Eoid := RingAsCategory( EEE );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := RingAsCategoryMorphism( Eoid, 1/2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b := RingAsCategoryMorphism( Eoid, -2/3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := RingAsCategoryUniqueObject( Eoid );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( a,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        u,u,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            a</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a = HomStructure( u, u, HomStructure( a ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForObjects( HomStructure( Eoid ), DistinguishedObjectOfHomomorphismStructure( Eoid ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := RingAsCategoryMorphism( Eoid, 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d := RingAsCategoryMorphism( Eoid, 0 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">left_coeffs := [ [ a, b ], [ c, d ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">right_coeffs := [ [ PreCompose( a, b ), PreCompose( b, c ) ], [ c, PreCompose( a, a ) ] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">right_side := [ a, b ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MereExistenceOfSolutionOfLinearSystemInAbCategory( left_coeffs, right_coeffs, right_side );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">solution := </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    SolveLinearSystemInAbCategory(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    left_coeffs,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    right_coeffs,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    right_side</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll( [ 1, 2 ], i -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    IsCongruentForMorphisms(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        Sum( List( [ 1, 2 ], j -&gt; PreCompose( [ left_coeffs[i][j], solution[j], right_coeffs[i][j] ] ) ) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        right_side[i]</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLiftable( c, d );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LiftOrFail( c, d );</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLiftable( d, c );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LiftOrFail( d, c );</span>
&lt;0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lift( d, c );</span>
&lt;0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsColiftable( c, d );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ColiftOrFail( c, d );</span>
&lt;0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Colift( c, d );</span>
&lt;0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsColiftable( d, c );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ColiftOrFail( d, c );</span>
fail
</pre></div>

<p><a id="X84C669D87B0599DB" name="X84C669D87B0599DB"></a></p>

<h4>12.15 <span class="Heading">Linear closure of categories</span></h4>


<div class="example"><pre>
#@if IsPackageMarkedForLoading( "FinSetsForCAP", "&gt;= 2023.07-03" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SymmetricGroup( 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CG := GroupAsCategory( G );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">compare_func := function( g, h ) return UnderlyingGroupElement( g ) &lt; UnderlyingGroupElement( h ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZZZ := HomalgRingOfIntegers();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZCG := LinearClosure( ZZZ, CG, compare_func );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := GroupAsCategoryUniqueObject( CG );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := GroupAsCategoryMorphism( (1,2,3), CG );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h := GroupAsCategoryMorphism( (1,2), CG );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v := LinearClosureObject( ZCG, u );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfObjectsOfCategory( ZCG ) = [ v ];</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elem1 := LinearClosureMorphism( v, [ 1, 2, 3, 4, 5, 6 ], [ g, h, g, h, g, h ], v );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elem2 := LinearClosureMorphism( v, [ 1, 2, 3, 4, 5, 6 ], [ h, g, h, g, h, g ], v );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># for i in [ 1 .. 10^6 ] do LinearClosureMorphism( v, [ 1, 2, 3, 4, 5, 6 ], [ g, h, g, h, g, h ], v ); od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elem := LinearClosureMorphism( v, [ 0, 0, 0, 0, 0, 0 ], [ g, h, g, h, g, h ], v );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := (1,2)/CG/ZCG;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b := (2,3)/CG/ZCG;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphism( a + b );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lift( a + b, a ) * a = a + b;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLiftable( a + b, -2*a ); ## over Q this is liftable</span>
false
#@fi
</pre></div>

<p><a id="X81E7031D85FD2569" name="X81E7031D85FD2569"></a></p>

<h4>12.16 <span class="Heading">Matrices over ZP K</span></h4>


<div class="example"><pre>
#@if IsPackageMarkedForLoading( "FinSetsForCAP", "&gt;= 2023.07-03" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">#Incidence matrix of our proset</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">K := [ [1, 1, 1], [0, 1, 1], [0, 1, 1] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">#Construction of a tower of categories</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">CP_K := ProSetAsCategory( K );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZZZ := HomalgRingOfIntegers( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZP_K := LinearClosure( ZZZ, CP_K, ReturnTrue );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RowsP_K := AdditiveClosure( ZP_K );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := ProSetAsCategoryObject( 1, CP_K );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b := ProSetAsCategoryObject( 2, CP_K );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := ProSetAsCategoryObject( 3, CP_K );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">#Three random objects in the additive closure</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">#Such that there exists morphisms from A-&gt;B and B-&gt;C:</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">rand_coef := List( [ 1 .. 5 ], i -&gt; Random( [ 2 .. 20 ] ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A1 := List( [ 1 .. rand_coef[ 1 ] ], i -&gt; a );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A2 := List( [ 1 .. rand_coef[ 2 ] ], i -&gt; b );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A := Concatenation( A1, A2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B1 := List( [ 1 .. rand_coef[ 3 ] ], i -&gt; b );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B2 := List( [ 1 .. rand_coef[ 4 ] ], i -&gt; c );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B :=  Concatenation( B1, B2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := List([ 1 .. rand_coef[ 5 ] ], i -&gt; c);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">#A random lifting problem over ZP_K</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">MA_B :=  List( [ 1 .. rand_coef[ 1 ] + rand_coef[ 2 ] ], i -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            List( [ 1 .. rand_coef[ 3 ] + rand_coef[ 4 ] ], j -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                LinearClosureMorphism( LinearClosureObject( A[i], ZP_K ), [Random( [ -20 .. 20 ] )], [ProSetAsCategoryMorphism( A[i], B[j] )], LinearClosureObject( B[j], ZP_K ) )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">              );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := MA_B/RowsP_K;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MB_C :=  List( [ 1 .. rand_coef[ 3 ] + rand_coef[ 4 ] ], i -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            List( [ 1 .. rand_coef[ 5 ] ], j -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                LinearClosureMorphism( LinearClosureObject( B[i], ZP_K ), [Random( [ -20 .. 20 ] )], [ProSetAsCategoryMorphism( B[i], C[j] )], LinearClosureObject( C[j], ZP_K ) )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := MB_C/RowsP_K;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := PreCompose( alpha, beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lift := Lift( gamma, beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreCompose(lift, beta) = gamma;</span>
true
#@fi
</pre></div>

<p><a id="X7F1E3F5A7EC538B6" name="X7F1E3F5A7EC538B6"></a></p>

<h4>12.17 <span class="Heading">Matrices over ZG</span></h4>

<p>Construction of a tower of categories</p>


<div class="example"><pre>
#@if IsPackageMarkedForLoading( "FinSetsForCAP", "&gt;= 2023.07-03" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := SymmetricGroup( 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CG := GroupAsCategory( G );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZZZ := HomalgRingOfIntegers( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ZCG := LinearClosure( ZZZ, CG );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RowsG := AdditiveClosure( ZCG );;</span>
#@fi
</pre></div>

<p>Construction of elements</p>


<div class="example"><pre>
#@if IsPackageMarkedForLoading( "FinSetsForCAP", "&gt;= 2023.07-03" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := (1,2)/CG/ZCG;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b := (2,3)/CG/ZCG;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e := ()/CG/ZCG;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">omega := [ [ a - e ], [ b - e ] ]/RowsG;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := GroupAsCategoryUniqueObject( CG );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v := LinearClosureObject( ZCG, u );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := AsAdditiveClosureObject( v );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HomStructure( u, omega );;</span>
#@fi
</pre></div>

<p>A random lifting problem over ZG</p>


<div class="example"><pre>
#@if IsPackageMarkedForLoading( "FinSetsForCAP", "&gt;= 2023.07-03" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elem := Elements( G );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">elem := List( elem, x -&gt; x/CG/ZCG );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rand_elem := function() local coeffs; coeffs := List( [ 1 .. 6 ], i -&gt; Random( [ -20 .. 20 ] ) ); if ForAll( coeffs, IsZero ) then return ZeroMorphism( v, v ); fi; return Sum( List( [ 1 .. 6 ], i -&gt; Random( [ -20 .. 20 ] ) * One( ZZZ ) * elem[i] ) ); end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat10_11 := List( [ 1 .. 10 ], i -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        List( [ 1 .. 11 ], j -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            rand_elem()</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat11_12 := List( [ 1 .. 11 ], i -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        List( [ 1 .. 12 ], j -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            rand_elem()</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := mat10_11/RowsG;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := mat11_12/RowsG;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := PreCompose( alpha, beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lift := Lift( gamma, beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreCompose( lift, beta ) = gamma;</span>
true
#@fi
</pre></div>

<p><a id="X8598E8828771FA9D" name="X8598E8828771FA9D"></a></p>

<h4>12.18 <span class="Heading">Opposite( CategoryOfRow ) as CategoryOfColumns</span></h4>

<p>Assume that we have the constructors <code class="code">CategoryOfRows</code> and <code class="code">CategoryOfColumns</code> but no constructor <code class="code">Opposite</code>. Then we can still model <code class="code">Opposite( CategoryOfRows )</code> as <code class="code">CategoryOfColumns</code> using <code class="code">ReinterpretationOfCategory</code>. This can be achieved up to minor modifications by swapping <code class="code">object_constructor</code> and <code class="code">modeling_tower_object_constructor</code> and so on in <code class="code">CategoryOfColums_as_Opposite_CategoryOfRows</code>. With this, objects and morphisms indeed have the attribute <code class="code">Opposite</code> as desired. Getting <code class="code">ObjectDatum</code> and <code class="code">MorphismDatum</code> to return this attribute would also be possible, but would require more effort than simply swapping <code class="code">object_constructor</code> and <code class="code">modeling_tower_object_constructor</code> and so.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FreydCategoriesForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ := HomalgFieldOfRationals( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cols := CategoryOfColumns( QQ );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rows := CategoryOfRows( QQ );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">object_constructor :=</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    { cat, rank } -&gt; CreateCapCategoryObjectWithAttributes( cat,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                                            Opposite, CategoryOfRowsObject( Opposite( cat ), rank )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">modeling_tower_object_constructor :=</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    { cat, rank } -&gt; CreateCapCategoryObjectWithAttributes( ModelingCategory( cat ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                                            RankOfObject, rank</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">object_datum := { cat, obj } -&gt; RankOfObject( Opposite( obj ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">modeling_tower_object_datum := { cat, obj } -&gt; RankOfObject( obj );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">morphism_constructor :=</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    { cat, source, underlying_matrix, range } -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        CreateCapCategoryMorphismWithAttributes(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            cat,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            source, range,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            Opposite, CategoryOfRowsMorphism(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                Opposite( cat ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                Opposite( range ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                underlying_matrix,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                Opposite( source )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">modeling_tower_morphism_constructor :=</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    { cat, source, underlying_matrix, range } -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        CreateCapCategoryMorphismWithAttributes(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            ModelingCategory( cat ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            source, range,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">            UnderlyingMatrix, underlying_matrix</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">morphism_datum := { cat, mor } -&gt; UnderlyingMatrix( Opposite( mor ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">modeling_tower_morphism_datum := { cat, mor } -&gt; UnderlyingMatrix( mor );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">op := ReinterpretationOfCategory( cols, rec(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    name := Concatenation( "Opposite( ", Name( rows )," )" ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    category_filter := WasCreatedAsOppositeCategory,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    category_object_filter := IsCapCategoryOppositeObject,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    category_morphism_filter := IsCapCategoryOppositeMorphism,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    object_constructor := object_constructor,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    object_datum := object_datum,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    morphism_constructor := morphism_constructor,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    morphism_datum := morphism_datum,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    modeling_tower_object_constructor := modeling_tower_object_constructor,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    modeling_tower_object_datum := modeling_tower_object_datum,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    modeling_tower_morphism_constructor := modeling_tower_morphism_constructor,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    modeling_tower_morphism_datum := modeling_tower_morphism_datum,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    only_primitive_operations := true,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">) );</span>
Opposite( Rows( Q ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOpposite( op, rows );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">source := ObjectConstructor( op, 1 );</span>
&lt;An object in Opposite( Rows( Q ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">range := ObjectConstructor( op, 2 );</span>
&lt;An object in Opposite( Rows( Q ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">zero := ZeroMorphism( source, range );</span>
&lt;A zero morphism in Opposite( Rows( Q ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sum := AdditionForMorphisms( zero, zero );</span>
&lt;A morphism in Opposite( Rows( Q ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># notice that source and range are indeed swapped compared to the above</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">Display( Source( Opposite( sum ) ) );</span>
A row module over Q of rank 2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Range( Opposite( sum ) ) );</span>
A row module over Q of rank 1
</pre></div>

<p><a id="X820CD9B28165BF9F" name="X820CD9B28165BF9F"></a></p>

<h4>12.19 <span class="Heading">Testing if an object is projective, injective, bijective, and computing projective/injective dimensions</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := HomalgRingOfIntegers();;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rows := CategoryOfRows( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">adelman := AdelmanCategory( rows );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rowobj := CategoryOfRowsObject( 1, rows );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := ProjectionInFactorOfDirectSum( [ rowobj, rowobj ], 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := AsAdelmanCategoryMorphism( alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj := CokernelObject( alpha );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsBijectiveObject( obj );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := 2 * IdentityMorphism( rowobj );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := AsAdelmanCategoryMorphism( beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj1 := CokernelObject( beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj2 := KernelObject( beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj3 := ImageObject( beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">obj4 := HomologyObject( beta, beta );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsBijectiveObject( obj1 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsInjective( obj1 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProjectiveDimension( obj1 );</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsBijectiveObject( obj2 );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsProjective( obj2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InjectiveDimension( obj2 );</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProjectiveDimension( obj3 );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InjectiveDimension( obj3 );</span>
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ProjectiveDimension( obj4 );</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InjectiveDimension( obj4 );</span>
2
</pre></div>

<p><a id="X7AFC8F247C00D608" name="X7AFC8F247C00D608"></a></p>

<h4>12.20 <span class="Heading">Prosets</span></h4>


<div class="example"><pre>
#@if IsPackageMarkedForLoading( "FinSetsForCAP", "&gt;= 2023.07-03" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K := [ [1, 1, 1], [0, 1, 1], [0, 1, 1] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := [ [1, 1, 0], [0, 1, 1], [0, 0, 1] ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P_K := ProSetAsCategory(K);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">#ProSetAsCategory(L);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := 1/P_K;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b := ProSetAsCategoryObject(2, P_K);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := ProSetAsCategoryObject(3, P_K);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d := ProSetAsCategoryObject(4, P_K);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">delta := ProSetAsCategoryMorphism(b, a);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined(a);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined(d);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined(delta);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := ProSetAsCategoryMorphism(a, b);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := ProSetAsCategoryMorphism(b, c);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := ProSetAsCategoryMorphism(a, c);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma = PreCompose(alpha, beta);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id_a := IdentityMorphism(a);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined(Inverse(alpha));</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta*Inverse(beta) = IdentityMorphism(b);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha = Lift(gamma, beta);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLiftable(beta, gamma);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Colift(alpha, gamma) = beta;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha = HomStructure(a, b, HomStructure(alpha));</span>
true
#@fi
</pre></div>

<p><a id="X7A810CDA83F2897F" name="X7A810CDA83F2897F"></a></p>

<h4>12.21 <span class="Heading">Tests</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FreydCategoriesForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := HomalgRingOfIntegers( ) ;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cat := CategoryOfColumns( R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A := RandomObjectByInteger( cat, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := RandomObjectByInteger( cat, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mor1 := RandomMorphismByInteger( cat, 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mor2 := RandomMorphismWithFixedSourceByInteger( cat, CategoryOfColumnsObject( cat, 3 ), 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mor3 := RandomMorphismWithFixedRangeByInteger( cat, CategoryOfColumnsObject( cat, 3 ), 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mor4 := RandomMorphismWithFixedSourceAndRangeByInteger( cat, CategoryOfColumnsObject( cat, 3 ), CategoryOfColumnsObject( cat, 4 ), 2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RankOfObject( Source( mor2 ) ) = 3;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RankOfObject( Range( mor3 ) ) = 3;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RankOfObject( Source( mor4 ) ) = 3;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RankOfObject( Range( mor4 ) ) = 4;</span>
true
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FreydCategoriesForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ := HomalgFieldOfRationalsInSingular( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQxy := QQ * "x,y";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EQQxy := KoszulDualRing( QQxy );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := KoszulDualRing( HomalgRingOfIntegersInSingular( ) * "x,y" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CAP_INTERNAL_GENERATE_DOCUMENTATION_FOR_CATEGORY_INSTANCES(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [ CategoryOfRows( R ), "CategoryOfRows of an arbitrary ring", 0 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [ CategoryOfRows( EQQxy ), "CategoryOfRows of an exterior algebra over a field", 1 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [ CategoryOfRows( QQxy ), "CategoryOfRows of a commutative ring", 1 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [ CategoryOfRows( QQ ), "CategoryOfRows of a field", 3 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "FreydCategoriesForCAP",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "CategoryOfRows.autogen.gd",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "Category of rows",</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    "Supported CAP operations"</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);</span>
</pre></div>

<p><a id="X789E61CF843CF960" name="X789E61CF843CF960"></a></p>

<h4>12.22 <span class="Heading">Category of relations</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := HomalgRingOfIntegers( 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">vec := CategoryOfRows( F );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rel := RelCategory( vec );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A := 1/vec/rel;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( A );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( id );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := HomalgMatrix( "[ 1, 2 ]", 2, 1, F )/vec;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha_rel := alpha/rel;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha_rel_inv := rel/alpha;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := PreCompose( alpha_rel_inv, alpha_rel );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( beta, id );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForMorphisms( beta, id );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := HomalgFieldOfRationalsInSingular() * "t";;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">t := IndeterminatesOfPolynomialRing( R )[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cocycle := function( a, b, c ) local e; e := CoastrictionToImage( UniversalMorphismIntoDirectSum( [ ReversedArrow( c ), Arrow( c ) ] ) ); return t^RankOfObject( KernelObject( e ) ); end;;</span>
#@if IsPackageMarkedForLoading( "FinSetsForCAP", "&gt;= 2023.07-03" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := TwistedLinearClosure( R, rel, cocycle );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := beta/T;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">delta := ZeroMorphism( 1/vec, 1/vec )/rel/T;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( 3*gamma - 3*gamma );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( delta, gamma );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := PreCompose( alpha_rel_inv/T, alpha_rel/T );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( beta - t * IdentityMorphism( Range( alpha_rel/T ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( ( gamma * delta ) * gamma - gamma * ( delta * gamma ) );</span>
true
#@fi
</pre></div>

<p><a id="X8001962586A4466B" name="X8001962586A4466B"></a></p>

<h4>12.23 <span class="Heading">Rings as Ab-categories</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CR := RingAsCategory( Integers );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := RingAsCategoryUniqueObject( CR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsObjectFiniteCategory( CR );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfObjectsOfCategory( CR ) = [ u ];</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := 2 / CR;</span>
&lt;2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOne( alpha );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MorphismDatum( alpha );</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( alpha );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha * alpha;</span>
&lt;4&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">-alpha;</span>
&lt;-2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( alpha + AdditiveInverse( alpha ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := RingAsCategoryMorphism( 1/2, CR );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( beta );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := IdentityMorphism( u );</span>
&lt;1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOne( gamma );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">delta := ZeroMorphism( u, u );</span>
&lt;0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( delta );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2 * alpha;</span>
&lt;4&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lift( alpha * alpha, alpha );</span>
&lt;2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Colift( alpha, alpha * alpha );</span>
&lt;2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BasisOfExternalHom( u, u );</span>
[ &lt;1&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CoefficientsOfMorphism( alpha );</span>
[ 2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( alpha, LinearCombinationOfMorphisms( u, CoefficientsOfMorphism( alpha ), BasisOfExternalHom( u, u ), u ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TensorUnit( CR );</span>
*
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TensorUnit( CR ) = u;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TensorProductOnObjects( u, u );</span>
*
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TensorProductOnObjects( u, u ) = u;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TensorProductOnMorphisms( alpha, beta );</span>
&lt;1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Braiding( u, u );</span>
&lt;1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DualOnObjects( u ) = u;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DualOnMorphisms( alpha ) = alpha;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EvaluationForDual( u );</span>
&lt;1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CoevaluationForDual( u );</span>
&lt;1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CoDualOnObjects( u ) = u;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CoDualOnMorphisms( beta ) = beta;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CoclosedEvaluationForCoDual( u );</span>
&lt;1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CoclosedCoevaluationForCoDual( u );</span>
&lt;1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EEE := KoszulDualRing( HomalgFieldOfRationalsInSingular( ) * "x,y" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CE := RingAsCategory( EEE );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := RingAsCategoryUniqueObject( CE );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := ("2 + 3 * e0 + 4 * e1 + 5 * e0*e1" / EEE) / CE;</span>
&lt;5*e0*e1+3*e0+4*e1+2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOne( alpha );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( alpha );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha * alpha;</span>
&lt;20*e0*e1+12*e0+16*e1+4&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">-alpha;</span>
&lt;-5*e0*e1-3*e0-4*e1-2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( alpha + AdditiveInverse( alpha ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := IdentityMorphism( u );</span>
&lt;1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsOne( gamma );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">delta := ZeroMorphism( u, u );</span>
&lt;0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( delta );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2 * alpha;</span>
&lt;10*e0*e1+6*e0+8*e1+4&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Lift( alpha * alpha, alpha );</span>
&lt;5*e0*e1+3*e0+4*e1+2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Colift( alpha, alpha * alpha );</span>
&lt;5*e0*e1+3*e0+4*e1+2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">basis := BasisOfExternalHom( u, u );</span>
[ &lt;1&gt;, &lt;e0&gt;, &lt;e1&gt;, &lt;e0*e1&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coeffs := CoefficientsOfMorphism( alpha );</span>
[ 2, 3, 4, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( alpha, LinearCombinationOfMorphisms( u, coeffs, basis, u ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u_op := Opposite( u );</span>
&lt;An object in Opposite( RingAsCategory( Q{e0,e1} ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha_op := Opposite( alpha );</span>
&lt;A morphism in Opposite( RingAsCategory( Q{e0,e1} ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">basis := BasisOfExternalHom( u_op, u_op );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">coeffs := CoefficientsOfMorphism( alpha_op );</span>
[ 2, 3, 4, 5 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( alpha_op, LinearCombinationOfMorphisms( u_op, coeffs, basis, u_op ) );</span>
true
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap11_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap13_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chap10_mj.html">10</a>  <a href="chap11_mj.html">11</a>  <a href="chap12_mj.html">12</a>  <a href="chap13_mj.html">13</a>  <a href="chap14_mj.html">14</a>  <a href="chap15_mj.html">15</a>  <a href="chap16_mj.html">16</a>  <a href="chap17_mj.html">17</a>  <a href="chap18_mj.html">18</a>  <a href="chap19_mj.html">19</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="https://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
