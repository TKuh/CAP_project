\section{Categories}

Classically, a category consists of a class of objects, a set of morphisms, identity morphisms, and a composition function
satisfying some simple axioms. In $\CapPkg$, we use a slightly different notion of a category.

\begin{definition}\label{definition:CapCategory}
 A \CapPkg category $\mathbf{C}$ consists of the following data:
 \begin{enumerate}
  \item A set $\Obj_{\mathbf{C}}$ of \textbf{objects}.
  \item For every pair $a,b \in \Obj_{\mathbf{C}}$, a set $\Hom_{\mathbf{C}}( a, b )$ of \textbf{morphisms}.
  \item For every pair $a,b \in \Obj_{\mathbf{C}}$, an equivalence relation $\sim_{a,b}$ on $\Hom_{\mathbf{C}}( a, b )$
  called \textbf{congruence for morphisms}.
  \item For every $a \in \Obj_{\mathbf{C}}$, an \textbf{identity morphism} $\id_a \in \Hom_{\mathbf{C}}( a, a )$.
  \item For every triple $a, b, c \in \Obj_{\mathbf{C}}$, a \textbf{composition function}
  \[
   \circ: \Hom_{\mathbf{C}}( b, c ) \times \Hom_{\mathbf{C}}( a, b ) \rightarrow \Hom_{\mathbf{C}}( a, c )
  \]
  compatible with the congruence, i.e., 
  if $\alpha, \alpha' \in \Hom_{C}( a, b )$, 
  $\beta, \beta' \in \Hom_{C}( b, c )$,
  $\alpha \sim_{a,b} \alpha'$ 
  and $\beta \sim_{b,c} \beta'$, 
  then $\beta \circ \alpha \sim_{a,c} \beta' \circ \alpha'$.
  \item For all $a, b \in \Obj_{\mathbf{C}}$, 
        $\alpha \in \Hom_{\mathbf{C}}( a, b )$, 
        we have 
        \[
        \left( \id_{b} \circ \alpha \right) \sim_{a,b} \alpha
        \]
        and
        \[
        \alpha \sim_{a,b} \left( \alpha \circ \id_{a} \right).
        \]
  \item For all $a,b,c,d \in \Obj_{\mathbf{C}}$, 
        $\alpha \in \Hom_{\mathbf{C}}( a, b )$, 
        $\beta \in \Hom_{\mathbf{C}}( b, c )$, 
        $\gamma \in \Hom_{\mathbf{C}}( c, d )$,
        we have
        \[
        \left(( \gamma \circ \beta ) \circ \alpha \right) \sim_{a,d} \left( \gamma \circ ( \beta \circ \alpha ) \right)
        \]
 \end{enumerate}
\end{definition}

So the main differences between a $\CapPkg$ category and a classical category are:
\begin{enumerate}
 \item A $\CapPkg$ category has a set of objects, not a class.
 \item A $\CapPkg$ cateogry has as an additional part of its datum a congruence for morphisms, and the
 axioms are stated with respect to this congruence, and not with respect to equality.
\end{enumerate}

We will see that the congruence for morphisms actually makes the implementation of some categories easier (for example
the category of presentations).

\begin{remark}
 Passing to the quotient sets $\Hom_{C}( a, b )/\sim_{a,b}$ gives rise to a classical category $\mathbf{D}$, because
 all constructions and axioms respects the congruence.
 It is usually the case that we actually want to study $\mathbf{D}$, but that it is easier to implement a $\CapPkg$ category $\mathbf{C}$
 giving rise to $\mathbf{D}$.
\end{remark}

\begin{remark}
 In terms of higher category theory, a $\CapPkg$ category is a $2$-category such that the $2$-morphism sets are either empty or a singleton.
\end{remark}

\begin{convention}
 Throughout this manual we will use \textit{category} as a short term for a \CapPkg category. 
 If we want to refer to the classical notion of a category (i.e. the one used in \cite{MLCWM}) we will use the term \textit{classical category}.
\end{convention}


\section{Equality Specifications}

\begin{specification}
 Every basic operation has to yield equal output for given equal input.
\end{specification}

Every basic operation takes finitely many arguments as an input and computes one single output.
Each input argument has one of the following types:
\begin{enumerate}
 \item $\Int$, an integer.
 \item $\Bool$, a boolean.
 \item $\Obj$, an object of a category.
 \item $\Hom( a, b )$, a morphism with source and range given by objects $a$ and $b$, respectively (this is a dependent type).
 \item $\ListObj$, a finite list of objects.
 \item $\ListMor$, a finite list of morphisms which possibly have different sources or ranges.
\end{enumerate}
These are also the possible output types except that an output never is a list. \\
We now specify what it means for two terms of the same type to be equal.
\begin{enumerate}
 \item For $\Int$ and $\Bool$, equality is given by the equality operations in $\GAP$.
 \item For $\ListObj$ and $\ListMor$, equality is given by entrywise equality.
 \item For $\Obj$, equality is given by the basic operation \texttt{IsEqualForObjects}.
 \item For $\Hom( a, b )$, equality is given by the basic operation \texttt{IsEqualForMorphisms}.
\end{enumerate}

Like every basic operation, \texttt{IsEqualForObjects} and \texttt{IsEqualForMorphisms} can be added to 
a category object using the corresponding add functions \texttt{AddIsEqualForObjects} and \texttt{AddIsEqualForMorphisms}.

\begin{remark}
 The basic operations \texttt{IsEqualForObjects} and \texttt{IsEqualForMorphisms} play the role
 of the equality functions of the sets $\Obj_{\mathbf{C}}$ and $\Hom_{\mathbf{C}}(a,b)$ in definition
 \ref{definition:CapCategory}. In particular, \texttt{IsEqualForMorphisms} shall not be confused
 with congruence for morphisms.
\end{remark}


\subsection{Specifications for \texttt{IsEqualForObjects}}
The basic operation \texttt{IsEqualForObjects} has a special specification.

\begin{specification}[\texttt{IsEqualForObjects}]
~
 \begin{enumerate}
  \item Input: two objects ($\Obj$).
  \item Output: a boolean ($\Bool$).
  \item \texttt{IsEqualForObjects} has to respect the \GAP function \texttt{IsIdenticalObj}, i.e., 
  for objects $a, a', b, b'$ such that \texttt{IsIdenticalObj}($a$, $a'$) and \texttt{IsIdenticalObj}($b$, $b'$) holds,
  \texttt{IsEqualForObjects}($a$, $b$) and \texttt{IsEqualForObjects}($a'$, $b'$) yield equal booleans.
  \item \texttt{IsEqualForObjects} has to give rise to an equivalence relation on the set of all objects together
  with \texttt{IsEqualForObjects} as an equality function.\todo{\GAP sets}
 \end{enumerate}
\end{specification}

\begin{remark}
 It is allowed for \texttt{IsEqualForObjects} to return \texttt{fail}. This is interpreted by \CapPkg as
 \textit{``I don't know if the two objects are equal''}.
\end{remark}

\subsection{Specifications for \texttt{IsEqualForMorphisms}}
The basic operation \texttt{IsEqualForMorphisms} has a special specification.

\begin{specification}[\texttt{IsEqualForMorphisms}]
~
 \begin{enumerate}
  \item Input: two morphisms ($\Hom(a,b)$) having equal sources and ranges.
  \item Output: a boolean ($\Bool$).
  \item \texttt{IsEqualForMorphisms} has to respect the \GAP function \texttt{IsIdenticalObj}, i.e., 
  for morphisms $\alpha, \alpha', \beta, \beta'$ such that \texttt{IsIdenticalObj}($\alpha$, $\alpha'$) and \texttt{IsIdenticalObj}($\beta$, $\beta'$) holds,
  \texttt{IsEqualForMorphisms}($\alpha$, $\beta$) and \texttt{IsEqualForMorphisms}($\alpha'$, $\beta'$) yield equal booleans.
  \item \texttt{IsEqualForMorphisms} has to give rise to an equivalence relation on the set of all morphisms with prescribed source and range together
  with \texttt{IsEqualForObjects} as an equality function.\todo{\GAP sets}
 \end{enumerate}
\end{specification}

\begin{remark}
 It is allowed for \texttt{IsEqualForMorphisms} to return \texttt{fail}. This is interpreted by \CapPkg as
 \textit{``I don't know if the two morphisms are equal''}.
\end{remark}



\subsection{\GAP Sets and \GAP Maps}

\section{Typing Specifications}

\begin{specification}
 Every basic operation has to match its type.
\end{specification}

\section{Mathematical Specifications}

\begin{specification}
 Every basic operation has to compute what it is supposed to compute.
\end{specification}

\section{The Importance of Specifications}