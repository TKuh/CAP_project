\section{Categories}

Classically, a category consists of a class of objects, a set of morphisms, identity morphisms, and a composition function
satisfying some simple axioms. In $\CapPkg$, we use a slightly different notion of a category.

\begin{definition}\label{definition:CapCategory}
 A \CapPkg category $\mathbf{C}$ consists of the following data:
 \begin{enumerate}
  \item A set $\Obj_{\mathbf{C}}$ of \textbf{objects}.
  \item For every pair $a,b \in \Obj_{\mathbf{C}}$, a set $\Hom_{\mathbf{C}}( a, b )$ of \textbf{morphisms}.
  \item For every pair $a,b \in \Obj_{\mathbf{C}}$, an equivalence relation $\sim_{a,b}$ on $\Hom_{\mathbf{C}}( a, b )$
  called \textbf{congruence for morphisms}.
  \item For every $a \in \Obj_{\mathbf{C}}$, an \textbf{identity morphism} $\id_a \in \Hom_{\mathbf{C}}( a, a )$.
  \item For every triple $a, b, c \in \Obj_{\mathbf{C}}$, a \textbf{composition function}
  \[
   \circ: \Hom_{\mathbf{C}}( b, c ) \times \Hom_{\mathbf{C}}( a, b ) \rightarrow \Hom_{\mathbf{C}}( a, c )
  \]
  compatible with the congruence, i.e., 
  if $\alpha, \alpha' \in \Hom_{C}( a, b )$, 
  $\beta, \beta' \in \Hom_{C}( b, c )$,
  $\alpha \sim_{a,b} \alpha'$ 
  and $\beta \sim_{b,c} \beta'$, 
  then $\beta \circ \alpha \sim_{a,c} \beta' \circ \alpha'$.
  \item For all $a, b \in \Obj_{\mathbf{C}}$, 
        $\alpha \in \Hom_{\mathbf{C}}( a, b )$, 
        we have 
        \[
        \left( \id_{b} \circ \alpha \right) \sim_{a,b} \alpha
        \]
        and
        \[
        \alpha \sim_{a,b} \left( \alpha \circ \id_{a} \right).
        \]
  \item For all $a,b,c,d \in \Obj_{\mathbf{C}}$, 
        $\alpha \in \Hom_{\mathbf{C}}( a, b )$, 
        $\beta \in \Hom_{\mathbf{C}}( b, c )$, 
        $\gamma \in \Hom_{\mathbf{C}}( c, d )$,
        we have
        \[
        \left(( \gamma \circ \beta ) \circ \alpha \right) \sim_{a,d} \left( \gamma \circ ( \beta \circ \alpha ) \right)
        \]
 \end{enumerate}
\end{definition}

So the main differences between a $\CapPkg$ category and a classical category are:
\begin{enumerate}
 \item A $\CapPkg$ category has a set of objects, not a class.
 \item A $\CapPkg$ cateogry has as an additional part of its datum a congruence for morphisms, and the
 axioms are stated with respect to this congruence, and not with respect to equality.
\end{enumerate}

We will see that the congruence for morphisms actually makes the implementation of some categories easier (for example
the category of presentations).

\begin{remark}
 Passing to the quotient sets $\Hom_{C}( a, b )/\sim_{a,b}$ gives rise to a classical category $\mathbf{D}$, because
 all constructions and axioms respects the congruence.
 It is usually the case that we actually want to study $\mathbf{D}$, but that it is easier to implement a $\CapPkg$ category $\mathbf{C}$
 giving rise to $\mathbf{D}$.
\end{remark}

\begin{remark}
 In terms of higher category theory, a $\CapPkg$ category is a $2$-category such that the $2$-morphism sets are either empty or a singleton.
\end{remark}

\begin{convention}
 Throughout this manual we will use \textit{category} as a short term for a \CapPkg category. 
 If we want to refer to the classical notion of a category (i.e. the one used in \cite{MLCWM}) we will use the term \textit{classical category}.
\end{convention}


\section{Equality Specifications}

\begin{specification}
 Every basic operation has to yield equal output for given equal input.
\end{specification}

Every basic operation takes finitely many arguments as an input and computes one single output.
Each input argument has one of the following types:
\begin{enumerate}
 \item $\Int$, an integer.
 \item $\Bool$, a boolean.
 \item $\Obj$, an object of a category.
 \item $\Hom( a, b )$, a morphism with source and range given by objects $a$ and $b$, respectively (this is a dependent type).
 \item $\ListObj$, a finite list of objects.
 \item $\ListMor$, a finite list of morphisms which possibly have different sources or ranges.
\end{enumerate}
These are also the possible output types except that an output never is a list. \\
We now specify what it means for two terms of the same type to be equal.
\begin{enumerate}
 \item For $\Int$ and $\Bool$, equality is given by the equality operations in $\GAP$.
 \item For $\ListObj$ and $\ListMor$, equality is given by entrywise equality.
 \item For $\Obj$, equality is given by the basic operation \texttt{IsEqualForObjects}.
 \item For $\Hom( a, b )$, equality is given by the basic operation \texttt{IsEqualForMorphisms}.
\end{enumerate}

Like every basic operation, \texttt{IsEqualForObjects} and \texttt{IsEqualForMorphisms} can be added to 
a category object using the corresponding add functions \texttt{AddIsEqualForObjects} and \texttt{AddIsEqualForMorphisms}.

\begin{remark}
 The basic operations \texttt{IsEqualForObjects} and \texttt{IsEqualForMorphisms} play the role
 of the equality functions of the sets $\Obj_{\mathbf{C}}$ and $\Hom_{\mathbf{C}}(a,b)$ in definition
 \ref{definition:CapCategory}. In particular, \texttt{IsEqualForMorphisms} shall not be confused
 with congruence for morphisms.
\end{remark}

\begin{remark}\label{remark:realization_of_types}
 The above listed types are differently realized in \CapPkg.
 \begin{itemize}
  \item For $\Int$, we use the realization of \GAP
  \item For $\Bool$, we use the realization of \GAP, but only the values \texttt{true} and \texttt{false}
  are allowed (exception: equality functions, see \ref{subsection:specifiactions_is_equal_for_objects} and \ref{subsection:specifiactions_is_equal_for_morphisms}).
  \item For $\Obj$, there is a \GAP filter \texttt{IsCapCategoryObject}.
  \item The dependent type $\Hom( a, b )$ is realized by \GAP objects within
 the filter \texttt{IsCapCategoryMorphism} having objects set
 for their attributes \texttt{Source} and \texttt{Range}.
  \item There are no special \GAP filters for $\ListObj$ and $\ListMor$, simply the \GAP \texttt{IsList}
  is used.
 \end{itemize}
\end{remark}


\subsection{Specifications for \texttt{IsEqualForObjects}}\label{subsection:specifiactions_is_equal_for_objects}
The basic operation \texttt{IsEqualForObjects} has a special specification.

\begin{specification}[\texttt{IsEqualForObjects}]
~
 \begin{enumerate}
  \item Input: two objects ($\Obj$).
  \item Output: a boolean ($\Bool$).
  \item \texttt{IsEqualForObjects} has to respect the \GAP function \texttt{IsIdenticalObj}, i.e., 
  for objects $a, a', b, b'$ such that \texttt{IsIdenticalObj}($a$, $a'$) and \texttt{IsIdenticalObj}($b$, $b'$) holds,
  \texttt{IsEqualForObjects}($a$, $b$) and \texttt{IsEqualForObjects}($a'$, $b'$) yield equal booleans.
  \item \texttt{IsEqualForObjects} has to give rise to an equivalence relation on the set of all objects together
  with \texttt{IsEqualForObjects} as an equality function.\todo{\GAP sets}
 \end{enumerate}
\end{specification}

\begin{remark}
 It is allowed for \texttt{IsEqualForObjects} to return \texttt{fail}. This is interpreted by \CapPkg as
 \textit{``I don't know if the two objects are equal''}.
\end{remark}

\subsection{Specifications for \texttt{IsEqualForMorphisms}}\label{subsection:specifiactions_is_equal_for_morphisms}
The basic operation \texttt{IsEqualForMorphisms} has a special specification.

\begin{specification}[\texttt{IsEqualForMorphisms}]
~
 \begin{enumerate}
  \item Input: two morphisms ($\Hom(a,b)$) having equal sources and ranges.
  \item Output: a boolean ($\Bool$).
  \item \texttt{IsEqualForMorphisms} has to respect the \GAP function \texttt{IsIdenticalObj}, i.e., 
  for morphisms $\alpha, \alpha', \beta, \beta'$ such that \texttt{IsIdenticalObj}($\alpha$, $\alpha'$) and \texttt{IsIdenticalObj}($\beta$, $\beta'$) holds,
  \texttt{IsEqualForMorphisms}($\alpha$, $\beta$) and \texttt{IsEqualForMorphisms}($\alpha'$, $\beta'$) yield equal booleans.
  \item \texttt{IsEqualForMorphisms} has to give rise to an equivalence relation on the set of all morphisms with prescribed source and range together
  with \texttt{IsEqualForObjects} as an equality function.\todo{\GAP sets}
 \end{enumerate}
\end{specification}

\begin{remark}
 It is allowed for \texttt{IsEqualForMorphisms} to return \texttt{fail}. This is interpreted by \CapPkg as
 \textit{``I don't know if the two morphisms are equal''}.
\end{remark}



\subsection{\GAP Sets and \GAP Maps}

\section{Typing Specifications}

\begin{specification}
 Every basic operation has to match its type.
\end{specification}

Every basic operation symbol has a type. To be more precise, it has a (dependent) function type.

\begin{example}\label{example:simple_typing}
 The type of $\IsZeroForObjects$ is
 \[
  \Obj \rightarrow \Bool.
 \]
 Given a term of type $\Obj$, the basic operation symbol $\IsZeroForObjects$ returns a term of type $\Bool$.
\end{example}

\begin{example}\label{example:simple_typing_with_morphism_input}
 For $a,b: \Obj$, the type of $\KernelObject$ is
 \[
  \Hom(a,b) \rightarrow \Obj.
 \]
 Given a term of type $\Hom(a,b)$, the basic operation symbol $\KernelObject$ returns a term of type $\Obj$.
\end{example}

\begin{example}\label{example:dependent_typing}
 For $a,b: \Obj$, the type of $\KernelEmb$ is
 \[
  \prod_{\phi: \Hom(a,b)} \Hom( \KernelObject(\phi), a ).
 \]
 Given a term of type $\Hom(a,b)$, the basic operation symbol $\KernelEmb$ returns a term of type $\Hom( \KernelObject(\phi), a )$.
 Thus $\KernelEmb$ has a dependent function type, because the type of its output depends on the input term.
\end{example}

For a basic operation to match its typing specification, it has to
\begin{enumerate}
 \item accept only input specified by its type, and throw an error otherwise,
 \item compute only output specified by its type.
\end{enumerate}

\todo{specify when not, for example for performance}The first item is (almost) always handled by \CapPkg.
If we add a basic operation to \CapPkg via an add function, \CapPkg ensures that every call of that
basic operation first triggers a type checking.
\\
The meaning and implications of the second item have to be analyzed carefully.
\begin{example}[\ref{example:simple_typing} continued]
 The output has to be a boolean (c.f. remark \ref{remark:realization_of_types}).
\end{example}

\begin{example}[\ref{example:simple_typing_with_morphism_input} continued]
 The output has to be an object (c.f. remark \ref{remark:realization_of_types}).
\end{example}

\begin{example}[\ref{example:dependent_typing}]
 The output type depends on the given input. Let $a$ denote the source, $b$ denote the range of the input morphism $\phi$.
 Then the range of the output morphism has to be equal (\texttt{IsEqualForObjects}) to $a$.
 The source of the output morphism has to be equal (\texttt{IsEqualForObjects}) to the output of $\KernelObject(\phi)$.
\end{example}

As seen in example \ref{example:dependent_typing}, basic operation symbols (like $\KernelObject$) can be part of
the type of other basic operations (like $\prod_{\phi: \Hom(a,b)} \Hom( \KernelObject(\phi), a )$).
To implement a coherent model of all basic operations, we have to take care that such dependences are fulfilled.
Fortunately, \CapPkg provides tools to help us with this task.

\begin{example}
 Strategies of an implementation of $\KernelObject$ and $\KernelEmb$ with the correct types:
 \begin{enumerate}
  \item Only implement $\KernelEmb$. \CapPkg will automatically derive (c.f. section \ref{section:derivations}) the basic operation
        $\KernelObject$ coherently for you (as the source of $\KernelEmb$).
  \item Implement $\KernelObject$ and the helper basic operation $\KernelEmbWithGivenKernelObject$.
        This is an operation getting as an input a morphism $\phi$ and the result of $\KernelObject( \phi )$,
        which we can then use to construct a morphism with $\KernelObject( \phi )$ as its source. \todo{section on WithGiven}
        \CapPkg will automatically derive (c.f. section \ref{section:derivations}) the basic operation
        $\KernelEmb$ coherently for you (by calling $\KernelEmbWithGivenKernelObject$ with the output of $\KernelObject$ as an input).
  \item Implement $\KernelObject$, $\KernelEmb$, and $\KernelEmbWithGivenKernelObject$, and enable caching for these functions (c.f. chapter \ref{chapter:caching}).
        There is a \todo{reference for redirection} redirection mechanism of \CapPkg that guarantees a correct typing.
 \end{enumerate}
 Of course, you always can only implement $\KernelObject$ and $\KernelEmb$, and prove the correct typing manually.
\end{example}



\section{Mathematical Specifications}

\begin{specification}
 Every basic operation has to compute what it is supposed to compute.
\end{specification}

\section{The Importance of Specifications}