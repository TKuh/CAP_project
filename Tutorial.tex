Although \CapPkg offers many features and many possibilities to tweak computations,
it is fairly simple to integrate already existing data types and algorithms in \GAP
into the \CapPkg setup. In this chapter we give you a hand at the very first steps, using some
examples and explaining the use and the effect of the commands in it.

\section{The category of groups}

When implementing a category in \CapPkg, one should always have the corresponding classical
category in mind. In this example we start with the category of groups. The objects in this
category will be the groups, the morphisms will be the homomorphisms of groups. Every category
in \CapPkg is presented by a category \GAP object. We start by creating this object.

\input{GAP_tex/group_example/CreateCategory_main}

The string is just the name of the category we have created, and the object the variable
\texttt{grps} refers to stores information about the category. We can now continue by
telling the category how operations on the objects or morphisms are performed by adding
functions the category. First, there should be a compose method for morphisms. In \GAP
morphisms of groups are composed via the \texttt{*} operator, so we use the two
argument function \texttt{\textbackslash *} as function for \textrm{PreCompose}.

\input{GAP_tex/group_example/AddPreCompose_main}

Now the composition of two morphisms will be computed by the \texttt{\textbackslash *} operation.
Another thing every category needs is a function to compute the identity morphism. For this
category of groups this can be done as follows.

\input{GAP_tex/group_example/AddIdentityMorphism_main}

The command used above exactly creates the identity morphism of a group. Since the category
has now all the functions we wanted it to have, we can finalize it.

\input{GAP_tex/group_example/Finalize_main}

Finalizing a category is necessary after adding all the wanted operation and befor constructing objects
for it. We can now create a group and tell the system that the group should be an object in the category.

\input{GAP_tex/group_example/AddGroup_main}

Now those groups are by \CapPkg considered objects in the category \texttt{grps}, and we can
ask them about their category. Also, they are now part of the \GAP filter \texttt{IsCapCategoryObject}.

\input{GAP_tex/group_example/GroupFilter_main}

Now manipulation of the groups is possible using the functions we have already provided to the category.
It is possible to construct the identity of a group, and compose it with itself.

\input{GAP_tex/group_example/IdentityMorphism_main}

Of course, one can also create a morphism between \texttt{S3} and \texttt{S4} and add it to the category.
After that, we can also compose it with the identity morphism.

\input{GAP_tex/group_example/AdditionalMorphism_main}

Please note that the constructors for objects and morphisms used in this example are the ones provided
by \GAP itself, and the only ``change'' done to the data structure was adding it to the category.
This is one of the design principles of \CapPkg. Already existing data structures and algorithms
can be integrated into the system with little to no effort, which makes it possible to integrate \CapPkg
into many existing projects.

This example was pretty basic and only a way to show the very basic structure of \CapPkg. The next example
will construct a more sophisticated category and some of the computational tools in \CapPkg.


\section{The category of rational vector spaces}

In this section, we will create the category of finite dimensional rational vector spaces. We are going
to realize this category as a sceletal category, i.e., the objects will be the nonnegative integers,
representing the dimension of the vector space, and we use appropriate matrices as morphisms. We start
by loading \CapPkg and the packages of the \texttt{homalg} project, and creating appropriate data structures
for the objects and morphisms of the category. The first part of this tutorial is taken from a file and not from
an interactive session.

In the first part, after loading the packages, we create types and representations for the objects
and morphisms of the category. Those are needed since we want to provide the data structure. For simplicity,
those representations are derived from the corresponding \CapPkg \GAP categories. This is not needed in general,
so one can use their own data structures without any changes. After that, we declare an attribute for vector spaces,
i.e., the dimension, which will be the only needed data of an object, as described above. Then we declare constructors
for objects and morphisms. The object constructor only has one attribute, which is the dimension of the vector space.
The morphism constructor has three arguments. A vector space, which is the \texttt{Source} of the morphism, a matrix
representing the morphism, and a second vector space, which is the \texttt{Range} of the morphism. Note that every morphism
which should be added to the category needs the \GAP attributes \texttt{Source} and \texttt{Range}, which will also be
added as obejcts to the category.

\input{GAP_tex/vecspaces_example/Declarations}

After the declarations of the constructors we create a global category \GAP object, which will be the category
of vector spaces and where we add all the objects and morphisms to, already in their constructors, which we create now.

\input{GAP_tex/vecspaces_example/Declarations2}

Those constructors are straight forward, they create the objects and morphisms with the desired attributes and then
add those to our previously created category. Since the objects, because of their type, already imply the \GAP filters
\texttt{IsCapCategoryObject} and \texttt{IsCapCategoryMorphism} respectively, we can use the operation \texttt{Add} instead
of \texttt{AddObject} and \texttt{AddMorphism}. Since \texttt{Add} is called in the constructor, the resulting obejcts and
morphisms are automatically part of the category, and after finishing up the category all the operations from the
category will be applicable to them.

We now continue by adding functions to the category, starting with the same operations as above.

\input{GAP_tex/vecspaces_example/Functions1}

Those functions are straight forward and do not require any additional explanation except the code. Before we continue
adding additional operations, there is another thing we have to take care of. The category of vector spaces we wanted
to create is a sceletal category, i.e., vector spaces of the same dimension are supposed to be equal. At the moment
two consecutive calls of the object constructor will not lead to equal objects, since there is no comparison function.
\CapPkg offers facilities to give correct comparison functions for objects and morphisms to the category. If no function
is given, the \GAP function \texttt{IsIdenticalObj} is used. However, giving the right equality function to the
category is important, please see the \todo{reference} section about equalities for details. We will now add equalities
for objects and morphisms. Objects will be compared by their dimension, for morphisms the matrices will be compared entrywise.
The equalities in \CapPkg do not need to be \texttt{true} or \texttt{false}, but are also allowed to return \texttt{fail},
which will be interpreted as non decidable. This is used for example for complexes.

\input{GAP_tex/vecspaces_example/Equalities}