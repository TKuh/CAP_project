Although \CapPkg offers many features and many possibilities to tweak computations,
it is fairly simple to integrate already existing data types and algorithms in \GAP
into the \CapPkg setup. In this chapter we give you a hand at the very first steps, using some
examples and explaining the use and the effect of the commands in it.

\section{The category of groups}

When implementing a category in \CapPkg, one should always have the corresponding classical
category in mind. In this example we start with the category of groups. The objects in this
category will be the groups, the morphisms will be the homomorphisms of groups. Every category
in \CapPkg is presented by a category \GAP object. We start by creating this object.

\input{GAP_tex/group_example/CreateCategory_main}

The string is just the name of the category we have created, and the object the variable
\texttt{grps} refers to stores information about the category. We can now continue by
telling the category how operations on the objects or morphisms are performed by adding
functions the category. First, there should be a compose method for morphisms. In \GAP
morphisms of groups are composed via the \texttt{*} operator, so we use the two
argument function \texttt{\textbackslash *} as function for \textrm{PreCompose}.

\input{GAP_tex/group_example/AddPreCompose_main}

Now the composition of two morphisms will be computed by the \texttt{\textbackslash *} operation.
Another thing every category needs is a function to compute the identity morphism. For this
category of groups this can be done as follows.

\input{GAP_tex/group_example/AddIdentityMorphism_main}

The command used above exactly creates the identity morphism of a group. Since the category
has now all the functions we wanted it to have, we can finalize it.

\input{GAP_tex/group_example/Finalize_main}

Finalizing a category is necessary after adding all the wanted operation and befor constructing objects
for it. We can now create a group and tell the system that the group should be an object in the category.

\input{GAP_tex/group_example/AddGroup_main}

Now those groups are by \CapPkg considered objects in the category \texttt{grps}, and we can
ask them about their category. Also, they are now part of the \GAP filter \texttt{IsCapCategoryObject}.

\input{GAP_tex/group_example/GroupFilter_main}

Now manipulation of the groups is possible using the functions we have already provided to the category.
It is possible to construct the identity of a group, and compose it with itself.

\input{GAP_tex/group_example/IdentityMorphism_main}

Of course, one can also create a morphism between \texttt{S3} and \texttt{S4} and add it to the category.
After that, we can also compose it with the identity morphism.

\input{GAP_tex/group_example/AdditionalMorphism_main}

Please note that the constructors for objects and morphisms used in this example are the ones provided
by \GAP itself, and the only ``change'' done to the data structure was adding it to the category.
This is one of the design principles of \CapPkg. Already existing data structures and algorithms
can be integrated into the system with little to no effort, which makes it possible to integrate \CapPkg
into many existing projects.

This example was pretty basic and only a way to show the very basic structure of \CapPkg. The next example
will construct a more sophisticated category and some of the computational tools in \CapPkg.
