Although \CapPkg offers many features and many possibilities to tweak computations,
it is fairly simple to integrate already existing data types and algorithms in \GAP
into the \CapPkg setup. In this chapter we give you a hand at the very first steps, using some
examples and explaining the use and the effect of the commands in it.

\section{The category of groups}

When implementing a category in \CapPkg, one should always have the corresponding classical
category in mind. In this example we start with the category of groups. The objects in this
category will be the groups, the morphisms will be the homomorphisms of groups. Every category
in \CapPkg is presented by a category \GAP object. We start by creating this object.

\input{GAP_tex/group_example/CreateCategory_main}

The string is just the name of the category we have created, and the object the variable
\texttt{grps} refers to stores information about the category. We can now continue by
telling the category how operations on the objects or morphisms are performed by adding
functions the category. First, there should be a compose method for morphisms. In \GAP
morphisms of groups are composed via the \texttt{*} operator, so we use the two
argument function \texttt{\textbackslash *} as function for \textrm{PreCompose}.

\input{GAP_tex/group_example/AddPreCompose_main}

Now the composition of two morphisms will be computed by the \texttt{\textbackslash *} operation.
Another thing every category needs is a function to compute the identity morphism. For this
category of groups this can be done as follows.

\input{GAP_tex/group_example/AddIdentityMorphism_main}

The command used above exactly creates the identity morphism of a group. Since the category
has now all the functions we wanted it to have, we can finalize it.

\input{GAP_tex/group_example/Finalize_main}

Finalizing a category is necessary after adding all the wanted operation and befor constructing objects
for it. We can now create a group and tell the system that the group should be an object in the category.

\input{GAP_tex/group_example/AddGroup_main}

Now those groups are by \CapPkg considered objects in the category \texttt{grps}, and we can
ask them about their category. Also, they are now part of the \GAP filter \texttt{IsCapCategoryObject}.

\input{GAP_tex/group_example/GroupFilter_main}

Now manipulation of the groups is possible using the functions we have already provided to the category.
It is possible to construct the identity of a group, and compose it with itself.

\input{GAP_tex/group_example/IdentityMorphism_main}

Of course, one can also create a morphism between \texttt{S3} and \texttt{S4} and add it to the category.
After that, we can also compose it with the identity morphism.

\input{GAP_tex/group_example/AdditionalMorphism_main}

Please note that the constructors for objects and morphisms used in this example are the ones provided
by \GAP itself, and the only ``change'' done to the data structure was adding it to the category.
This is one of the design principles of \CapPkg. Already existing data structures and algorithms
can be integrated into the system with little to no effort, which makes it possible to integrate \CapPkg
into many existing projects.

This example was pretty basic and only a way to show the very basic structure of \CapPkg. The next example
will construct a more sophisticated category and some of the computational tools in \CapPkg.


\section{The category of rational vector spaces}

In this section, we will create the category of finite dimensional rational vector spaces as an
example of an abelian category. We are going
to realize this category as a sceletal category, i.e., the objects will be the nonnegative integers,
representing the dimension of the vector space, and we use appropriate matrices as morphisms. We start
by loading \CapPkg and the packages of the \texttt{homalg} project, and creating appropriate data structures
for the objects and morphisms of the category. The first part of this tutorial is taken from a file and not from
an interactive session. Please note that for the sake of completeness, all the necessary code to create the
functions is displayed. This might seem confusing or simply to much. If you only want to have a look how a \CapPkg category
is initialized, only look at the headers of the functions. Also, once the whole process of creation is finished,
there are examples for computations in the category. If you are interested in the capability of \CapPkg, please
continue at \todo{reference}.

In the first part, after loading the packages, we create types and representations for the objects
and morphisms of the category. Those are needed since we want to provide the data structure. For simplicity,
those representations are derived from the corresponding \CapPkg \GAP categories. This is not needed in general,
so one can use their own data structures without any changes. After that, we declare an attribute for vector spaces,
i.e., the dimension, which will be the only needed data of an object, as described above. Then we declare constructors
for objects and morphisms. The object constructor only has one attribute, which is the dimension of the vector space.
The morphism constructor has three arguments. A vector space, which is the \texttt{Source} of the morphism, a matrix
representing the morphism, and a second vector space, which is the \texttt{Range} of the morphism. Note that every morphism
which should be added to the category needs the \GAP attributes \texttt{Source} and \texttt{Range}, which will also be
added as obejcts to the category.

\input{GAP_tex/vecspaces_example/Declarations}

After the declarations of the constructors we created a global category \GAP object, which will be the category
of vector spaces and where we add all the objects and morphisms to, already in their constructors, which we create now.
Since we are going to create an Abelian category, we tell the system that we are doing this, to have all the computational
properties of an Abelian category.

\input{GAP_tex/vecspaces_example/Declarations2}

Those constructors are straight forward, they create the objects and morphisms with the desired attributes and then
add those to our previously created category. Since the objects, because of their type, already imply the \GAP filters
\texttt{IsCapCategoryObject} and \texttt{IsCapCategoryMorphism} respectively, we can use the operation \texttt{Add} instead
of \texttt{AddObject} and \texttt{AddMorphism}. Since \texttt{Add} is called in the constructor, the resulting obejcts and
morphisms are automatically part of the category, and after finishing up the category all the operations from the
category will be applicable to them.

We now continue by adding functions to the category, starting with the same operations as above.

\input{GAP_tex/vecspaces_example/Functions1}

Those functions are straight forward and do not require any additional explanation except the code. Before we continue
adding additional operations, there is another thing we have to take care of. The category of vector spaces we wanted
to create is a sceletal category, i.e., vector spaces of the same dimension are supposed to be equal. At the moment
two consecutive calls of the object constructor will not lead to equal objects, since there is no comparison function.
\CapPkg offers facilities to give correct comparison functions for objects and morphisms to the category. If no function
is given, the \GAP function \texttt{IsIdenticalObj} is used. However, giving the right equality function to the
category is important, please see the \todo{reference} section about equalities for details. We will now add equalities
for objects and morphisms. Objects will be compared by their dimension, for morphisms the matrices will be compared entrywise.
The equalities in \CapPkg do not need to be \texttt{true} or \texttt{false}, but are also allowed to return \texttt{fail},
which will be interpreted as non decidable. This is used for example for complexes.

\input{GAP_tex/vecspaces_example/Equalities}

Next we implement some additional functions in the category of vector spaces. We start by definining functions for the kernel.
A proper implementation needs at least two functions. One for \texttt{KernelEmb}, which can compute the embedding of the kernel
into the source of the given morphism. From this function then automatically a function for \texttt{KernelObject} is derived, which
computes the embedding and returns the source of this morphism. The second one, \texttt{KernelLift}, implements the universal property of the kernel.
The diagram of the kernel looks like this:
\begin{center}
\begin{tikzpicture}[description/.style={fill=white,inner sep=2pt}]
  \matrix (m) [matrix of math nodes, row sep=3em,
               column sep=2.5em, text height=1.5ex, text depth=0.25ex]
  { \mathrm{KernelObject} \left( \alpha \right) & & \\
    & A & B \\
    T & & \\ };
  \path[->] (m-1-1) edge node[auto]{$\mathrm{KernelEmb} \left( \alpha \right)$} (m-2-2);
  \path[->] (m-2-2) edge node[auto]{$\alpha$} (m-2-3);
  \path[->] (m-3-1) edge node[auto]{$\beta$} (m-2-2);
  \path[->, dashed] (m-3-1) edge node[auto]{$\mathrm{KernelLift} \left( \alpha, \beta \right)$} (m-1-1);
  \path[->] (m-3-1) edge[bend right] node[auto]{$0$} (m-2-3);
\end{tikzpicture}
\end{center}

Please note that it is important that the range of the output morphism of the function we give to \texttt{KernelLift},
under equal first argument, must coincide with the source of the output morphism of the function given to \texttt{KernelEmb}.
In our case this simply means they need to have the same dimension.

\input{GAP_tex/vecspaces_example/Kernel}

There are two things to mention here.
First thing, instead of \texttt{KernelLift} we could also have installed another method,
called \texttt{KernelLiftWithGivenKernelObject}. The result would again be an implementation of \texttt{KernelLift}, but those
\texttt{WithGiven} operations offer an advantage. Instead of calling a function with only $\alpha$ and $\beta$, there
would be a third argument, which should be equal to the output of \texttt{KernelObject} and then serves as the range of the output morphism.
This can be done to ensure better compatibility if the given equality function for objects might not be complete, or to save computation time.
Please have a look at \ref{chapter:constructions} for more details about the \texttt{WithGiven} functions.

Also, the function given for \texttt{KernelLift} does at the beginning the the same as the function given for \texttt{KernelEmb}. This might to
a unnecessary computation. So, in this context, it would be better to provide a more general function for \texttt{MonoAsKernelLift}.
The input for this function would be a mono, and some morphism, would then provide a lift. The function for \texttt{KernelLift} would then be derived
from this operation and \texttt{KernelEmb}, by computing
\[
 \mathrm{MonoAsKernelLift} \left( \mathrm{KernelEmb} \left( \alpha \right), \beta \right).
\]
For more information about this system, please refer to the derivations section \ref{section:derivations}.
An implementation of the kernel would then instead look like this.

\input{GAP_tex/vecspaces_example/KernelAlternative}

We now see the code duplication from above disappear.

We now continue by adding more functionality to the category. Dual to our second implementation of the kernel,
we will provide functions for the cokernel.

\input{GAP_tex/vecspaces_example/Cokernel}

The next step is implementing functions for the \textrm{ZeroObject} in the category, i.e. the vector space
of dimension 0. A proper implementation here needs three algorithms. One, without any arguments, returns the
zero object of the category. The other two should, given one object, compute the unique morphisms from and into
the zero object. Those are named \texttt{UniversalMorphismIntoZeroObject} and \texttt{UniversalMorphismFromZeroObject}.
For those there are again two choices, either using the \texttt{WithGiven} operations or not.
For our example we do both, providing functions for the \texttt{WithGiven} operations and for the ones that
need to compute their own zero object. Please note that this is again possible because of the installed equality of objects.

\input{GAP_tex/vecspaces_example/ZeroObject}

Now we turn the set of homomorphisms between two objects into an Abelian group. For this, we need to define the addition of
two morphisms having the same sources and ranges, the additive inverse of a morphism, and the zero morphism between two objects.

\input{GAP_tex/vecspaces_example/HomSets}

The installation of \texttt{ZeroMorphism} is not necessary here, since we have the zero object and the corresponding
universal morphisms, this method could also be derived from those. Of course, providing a prmitive implementation might
increase the speed of some computations.

The last thing left to implement is the direct sum and its universal properties. After that, we can tell the system that the
category is abelian, finalize it, and start computations. The direct sum needs, for a proper implementation, at least five
functions. At first, the direct sum of objects needs to be created. Then there are injections of the components and projections
to the factors. Finally, since the direct sum is product and coproduct at the same time, there are two universal properties to be implemented.
For details please have a look at \ref{chapter:constructions}.

\input{GAP_tex/vecspaces_example/DirectSum}

Now we can finalize the category.

\input{GAP_tex/vecspaces_example/Finalize}

The finalize step is in this case very important. It triggers further derivations of methods, which depend on the fact that
some operations are not installed previously, and will not be installed anymore. Also it makes it possible to construct further
categories, like the category of complexes. We now initialize an interactive session with this implementation of vector spaces
and start by creating some morphisms.

\begin{small}
\input{GAP_tex/vecspaces_example/CreateMorphisms_main}
\end{small}

Unsuprisingly, we can now compute some of the stuff we told the system how to compute, for example the \texttt{KernelEmb},
which is the embedding of the kernel. Also, the cokernel and its projection can be computed. Those computations will
be carried out using the functions we have given to the system. It is also possible to use the standard arithmetic on the morphism.
Even if the added functions have different names, e.g., \texttt{AdditionForMorphisms}, it is possible to use the \GAP arithmetic
operations, e.g., \texttt{+}, for it.

\begin{small}
\input{GAP_tex/vecspaces_example/KernelExample_main}
\end{small}

The fact that such functions work properly are not suprising at all. But \CapPkg has the power to derive
further constructions from the given functions. Here are some examples of methods now applicable.

\begin{small}
\input{GAP_tex/vecspaces_example/DerivedMethodsExample_main}
\end{small}



