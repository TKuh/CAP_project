\CapPkg supports categorical constructions 
for a category $\mathbf{C}$
of the following types:

\begin{itemize}
 \item Basic constructions which only depend on the fact that $\mathbf{C}$ is category,
 such as composition ($\PreCompose$), identity ($\IdentityMorphism$), decisions whether
 a morphism is a mono, epi, or iso ($\IsMonomorphism, \IsEpimorphism, \IsIsomorphism$).
 \item Some limit and colimit constructions, such as direct product ($\DirectProduct$),
 coproduct ($\Coproduct$), fiber product ($\FiberProduct$), pushout ($\Pushout$),
 kernel ($\KernelObject$), cokernel ($\Cokernel$).
 \item Constructions for monoidal categories, such as tensor product ($\TensorProductOnObjects$, $\TensorProductOnMorphisms$),
 unitors ($\LeftUnitor$, $\RightUnitor$), associators \\($\AssociatorLeftToRight$, $\AssociatorRightToLeft$),
 internal hom ($\InternalHomOnObjects$, $\InternalHomOnMorphisms$).
\end{itemize}

\begin{notation}
 For the definition of a category, see chapter \ref{chapter:specifications}, section \ref{section:categories}.
\end{notation}


\section{Basic Constructions}

\section{Limits and Colimits}\label{section:universalobjects}

In \CapPkg, support is given for the implementation of some special kinds of limits and
colimits. We first give the definition of a limit and a colimit.
Let $\mathbf{C}$ be a category. Let $\mathbf{I}$ be another category (called an \textbf{index category}) and $D: \mathbf{I} \rightarrow \mathbf{C}$
be a functor (called a \textbf{diagram}). 
\begin{definition} 
 A \textbf{source} of $D$ is a collection of morphisms $( s_i: S \rightarrow D_i)_{i \in \mathbf{I}}$ such that
 $\left( D( i \rightarrow j ) \circ s_i \right) \sim_{S,D_j} s_j$ for every arrow $(i \rightarrow j) \in \mathbf{I}$.
\end{definition}
 
\begin{definition}
 A triple $(L, \lambda, u)$ consisting of the following data:
 \begin{enumerate}
  \item an object $L \in \mathbf{C}$,
  \item a source $\lambda = ( \lambda_i: L \rightarrow D_i)_{i \in \mathbf{I}}$,
  \item a dependent function $u$ mapping every source $\tau = ( \tau_i: T \rightarrow D_i )_{i \in \mathbf{I}}$
        to a morphism $u( \tau ): T \rightarrow L$ such that
        $\lambda_i \circ u( \tau ) \sim_{T,D_i} \tau_i$,
 \end{enumerate}
 is called a \textbf{limit of the diagram $D$}, if the morphisms $u(\tau)$ are uniquely determined up to
 congruence of morphisms.
\end{definition}

\begin{definition}
 A \textbf{sink} of $D$ is a collection of morphisms $( s_i: D_i \rightarrow S )_{i \in \mathbf{I}}$
 such that $\left(s_i \circ D( i \rightarrow j )\right) \sim_{D_i, S} s_j$ for every arrow $(i \rightarrow j) \in \mathbf{I}$.
\end{definition}


\begin{definition}
 A triple $(C, c, u)$ consisting of the following data:
 \begin{enumerate}
  \item an object $C \in \mathbf{C}$,
  \item a sink $c = ( c_i: D_i \rightarrow C )_{i \in \mathbf{I}}$,
  \item a dependent function $u$ mapping every source $\tau = ( \tau_i: D_i \rightarrow T )_{i \in \mathbf{I}}$
        to a morphism $u( \tau ): C \rightarrow T$ such that
        $u(\tau) \circ c_{i} \sim_{D_i,T} \tau_i$,
 \end{enumerate}
 is called a \textbf{colimit of the diagram $D$}, if the morphisms $u(\tau)$ are uniquely determined up to
 congruence of morphisms.
\end{definition}

\begin{example}
 Examples of limits are kernels, direct products, fiber products.
\end{example}

\begin{example}
 Examples of colimits are cokernels, coproducts, pushouts.
\end{example}

\subsection{Limits in \CapPkg}

For every limit $\left(L, \lambda = ( \lambda_i: L \rightarrow D_i)_{i \in \mathbf{I}} \right)$ in \CapPkg, 
there are three basic operations.

\begin{enumerate}
 \item A basic operation returning the limit object. The argument is the diagram:
 \[
  D \mapsto L.
 \]
 \item A basic operation returning the limit source. The argument is the diagram:
 \[
  D \mapsto \lambda.
 \]
 \item A basic operation returning the morphism given by the universal property. 
       The arguments are the diagram and a test source:
 \[
  ( D, \tau ) \mapsto u(\tau).
 \]
\end{enumerate}

\begin{example}
 In the case of a kernel, the three basic operations in question are
 \begin{enumerate}
  \item $\KernelObject$,
  \item $\KernelEmb$,
  \item $\KernelLift$.
 \end{enumerate} 
\end{example}

In addition, there are two more basic operations which are variants of the second
and the third basic operation one.

\begin{enumerate}
 \item A basic operation returning the limit source. The arguments are the diagram
       and an object equal ($\IsEqualForObjects$) to the limit object:
       \[
        ( D, L ) \mapsto \lambda.
       \]
  \item A basic operation returning the morphism given by the universal property.
        The arguments are the diagram, a test source, and an object equal ($\IsEqualForObjects$)
        to the limit object:
        \[
         ( D, \tau, L ) \mapsto u( \tau ).
        \]
\end{enumerate}

\begin{example}
 In the case of a kernel, the two variants in question are
 \begin{enumerate}
  \item $\KernelEmbWithGivenKernelObject$,
  \item $\KernelLiftWithGivenKernelObject$.
 \end{enumerate} 
\end{example}

We call such basic operations \texttt{WithGiven} operations.
We recommend not to call the \texttt{WithGiven} operations but only to implement them
as helpers in the following sense:
Depending on which of the above five basic operations are implemented, \CapPkg
automatically tries to fill in the missing operations:

\begin{itemize}
 \item Given $D \mapsto L$ and $( D, L ) \mapsto \lambda$, \CapPkg derives $D \mapsto \lambda$.
 \item Given $D \mapsto L$ and $( D, \tau, L ) \mapsto u( \tau )$, \CapPkg derives $( D, \tau ) \mapsto u(\tau)$.
\end{itemize}

Moreover, if the three basic operations $D \mapsto L$, $D \mapsto \lambda$, and $( D, L ) \mapsto \lambda$
are all given, then \CapPkg automatically enhances $D \mapsto \lambda$ with a \textbf{redirect function}.
The redirect function first looks if the limit object $L$ is already in the cache of $D \mapsto L$
(compared with a user given equality function, default option is $\IsEqualForObjects$).
If this is the case, \CapPkg automatically calls the \texttt{WithGiven} operation $( D, L ) \mapsto \lambda$
with the input $L$ found in the cache.

Analogously, \CapPkg enhances $( D, \tau ) \mapsto u(\tau)$ with a redirect function if
the three basic operations $D \mapsto L, ( D, \tau ) \mapsto u(\tau), ( D, \tau, L ) \mapsto u( \tau )$ are all given.

We will now define the limits and colimits available in \CapPkg.

\subsection{Direct Product}

\begin{definition}
 For a given list of objects $D = ( P_1, \dots, P_n )$, a direct product of $D$ consists of three parts:
 \begin{enumerate}
  \item an object $P$,
  \item a list of morphisms $\pi = ( \pi_i: P \rightarrow P_i )_{i = 1 \dots n}$ 
  \item a dependent function $u$ mapping each list of morphisms $\tau = ( \tau_i: T \rightarrow P_i )_{i = 1, \dots, n}$ 
  to a morphism $u(\tau): T \rightarrow P$ such that $\pi_i \circ u( \tau ) \sim_{T,P_i} \tau_i$ for all $i = 1, \dots, n$.
 \end{enumerate}
 The triple $( P, \pi, u )$ is called a \textbf{direct product of $D$} if the morphisms $u( \tau )$ are uniquely determined up to
 congruence of morphisms.
\end{definition}

\subsection{Coproduct}

\begin{definition}
 For a given list of objects $D = ( C_1, \dots, C_n )$, a coproduct of $D$ consists of three parts:
 \begin{enumerate}
  \item an object $C$,
  \item a list of morphisms $\iota = ( \iota_i: C_i \rightarrow C )_{i = 1 \dots n}$
  \item a dependent function $u$ mapping each list of morphisms $\tau = ( \tau_i: C_i \rightarrow T )$
  to a morphism $u( \tau ): C \rightarrow T$ such that $u( \tau ) \circ \iota_i \sim_{C_i, T} \tau_i$ for all $i = 1, \dots, n$.
 \end{enumerate}
 The triple $( C, \iota, u )$ is called a \textbf{coproduct of $D$} if the morphisms $u( \tau )$ are uniquely determined up to
 congruence of morphisms.
\end{definition}

\subsection{Fiber Product}

\begin{definition}
 For a given list of morphisms $D = ( \beta_i: P_i \rightarrow B )_{i = 1 \dots n}$, 
 a fiber product of $D$ consists of three parts:
 \begin{enumerate}
  \item an object $P$,
  \item a list of morphisms $\pi = ( \pi_i: P \rightarrow P_i )_{i = 1 \dots n}$ such that
        $\beta_i \circ \pi_i  \sim_{P, B} \beta_j \circ \pi_j$ for all pairs $i,j$.
  \item a dependent function $u$ mapping each list of morphisms
        $\tau = ( \tau_i: T \rightarrow P_i )$ such that
        $\beta_i \circ \tau_i  \sim_{P, B} \beta_j \circ \tau_j$ for all pairs $i,j$
        to a morphism $u( \tau ): T \rightarrow P$ such that
        $\pi_i \circ u( \tau ) \sim_{T, P_i} \tau_i$ for all $i = 1, \dots, n$.
 \end{enumerate}
 The triple $( P, \pi, u )$ is called a \textbf{fiber product of $D$} if the morphisms $u( \tau )$ are uniquely determined up to
 congruence of morphisms.
\end{definition}


\section{Monoidal Categories}

\section{Derivations}\label{section:derivations}