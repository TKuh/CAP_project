# SPDX-License-Identifier: GPL-2.0-or-later
# CAP: Categories, Algorithms, Programming
#
# Implementations
#
# THIS FILE IS AUTOMATICALLY GENERATED, SEE LimitConvenience.gi
##
AddDerivationToCAP( ProjectionInFactorOfDirectProductWithGivenDirectProduct,
                    [ [ ProjectionInFactorOfDirectProduct, 1 ] ],
  function( cat, objects, k, with_given_object )
    
    return ProjectionInFactorOfDirectProduct( cat, objects, k );
    
end : Description := "ProjectionInFactorOfDirectProductWithGivenDirectProduct by calling ProjectionInFactorOfDirectProduct with the last argument dropped" );

##
AddDerivationToCAP( ProjectionInFactorOfDirectProduct,
                    [ [ ProjectionInFactorOfDirectProductWithGivenDirectProduct, 1 ],
                      [ DirectProduct, 1 ] ],
  function( cat, objects, k )
    
    return ProjectionInFactorOfDirectProductWithGivenDirectProduct( cat, objects, k, DirectProduct( cat, objects ) );
    
end : Description := "ProjectionInFactorOfDirectProduct by calling ProjectionInFactorOfDirectProductWithGivenDirectProduct with DirectProduct as last argument" );

##
AddDerivationToCAP( UniversalMorphismIntoDirectProductWithGivenDirectProduct,
                    [ [ UniversalMorphismIntoDirectProduct, 1 ] ],
  function( cat, objects, T, tau, with_given_object )
    
    return UniversalMorphismIntoDirectProduct( cat, objects, T, tau );
    
end : Description := "UniversalMorphismIntoDirectProductWithGivenDirectProduct by calling UniversalMorphismIntoDirectProduct with the last argument dropped" );

##
AddDerivationToCAP( UniversalMorphismIntoDirectProduct,
                    [ [ UniversalMorphismIntoDirectProductWithGivenDirectProduct, 1 ],
                      [ DirectProduct, 1 ] ],
  function( cat, objects, T, tau )
    
    return UniversalMorphismIntoDirectProductWithGivenDirectProduct( cat, objects, T, tau, DirectProduct( cat, objects ) );
    
end : Description := "UniversalMorphismIntoDirectProduct by calling UniversalMorphismIntoDirectProductWithGivenDirectProduct with DirectProduct as last argument" );

##
AddDerivationToCAP( InjectionOfCofactorOfCoproductWithGivenCoproduct,
                    [ [ InjectionOfCofactorOfCoproduct, 1 ] ],
  function( cat, objects, k, with_given_object )
    
    return InjectionOfCofactorOfCoproduct( cat, objects, k );
    
end : Description := "InjectionOfCofactorOfCoproductWithGivenCoproduct by calling InjectionOfCofactorOfCoproduct with the last argument dropped" );

##
AddDerivationToCAP( InjectionOfCofactorOfCoproduct,
                    [ [ InjectionOfCofactorOfCoproductWithGivenCoproduct, 1 ],
                      [ Coproduct, 1 ] ],
  function( cat, objects, k )
    
    return InjectionOfCofactorOfCoproductWithGivenCoproduct( cat, objects, k, Coproduct( cat, objects ) );
    
end : Description := "InjectionOfCofactorOfCoproduct by calling InjectionOfCofactorOfCoproductWithGivenCoproduct with Coproduct as last argument" );

##
AddDerivationToCAP( UniversalMorphismFromCoproductWithGivenCoproduct,
                    [ [ UniversalMorphismFromCoproduct, 1 ] ],
  function( cat, objects, T, tau, with_given_object )
    
    return UniversalMorphismFromCoproduct( cat, objects, T, tau );
    
end : Description := "UniversalMorphismFromCoproductWithGivenCoproduct by calling UniversalMorphismFromCoproduct with the last argument dropped" );

##
AddDerivationToCAP( UniversalMorphismFromCoproduct,
                    [ [ UniversalMorphismFromCoproductWithGivenCoproduct, 1 ],
                      [ Coproduct, 1 ] ],
  function( cat, objects, T, tau )
    
    return UniversalMorphismFromCoproductWithGivenCoproduct( cat, objects, T, tau, Coproduct( cat, objects ) );
    
end : Description := "UniversalMorphismFromCoproduct by calling UniversalMorphismFromCoproductWithGivenCoproduct with Coproduct as last argument" );

##
InstallMethod( UniversalMorphismIntoDirectProduct,
               [ IsList ],
               
  function( list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismIntoDirectProduct( CapCategory( list[1] ), list );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectProduct,
               [ IsCapCategory, IsList ],
               
  function( cat, list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismIntoDirectProduct( cat, List( list, Range ), list );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectProduct,
               [ IsCapCategoryObject, IsList ],
               
  function( test_object, list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismIntoDirectProduct( CapCategory( test_object ), test_object, list );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectProduct,
               [ IsCapCategory, IsCapCategoryObject, IsList ],
               
  function( cat, test_object, list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismIntoDirectProduct( cat, List( list, Range ), test_object, list );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectProduct,
               [ IsCapCategoryMorphism ],
               
  function( mor1 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismIntoDirectProduct( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismIntoDirectProduct( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismIntoDirectProduct( [ mor1 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectProduct,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismIntoDirectProduct( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismIntoDirectProduct( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismIntoDirectProduct( [ mor1, mor2 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectProduct,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismIntoDirectProduct( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismIntoDirectProduct( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismIntoDirectProduct( [ mor1, mor2, mor3 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectProduct,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3, mor4 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismIntoDirectProduct( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismIntoDirectProduct( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismIntoDirectProduct( [ mor1, mor2, mor3, mor4 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectProduct,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3, mor4, mor5 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismIntoDirectProduct( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismIntoDirectProduct( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismIntoDirectProduct( [ mor1, mor2, mor3, mor4, mor5 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectProduct,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3, mor4, mor5, mor6 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismIntoDirectProduct( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismIntoDirectProduct( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismIntoDirectProduct( [ mor1, mor2, mor3, mor4, mor5, mor6 ] );
    
end );

InstallOtherMethod( UniversalMorphismIntoDirectProduct,
                    [ IsList, IsList ],
                    
    function( diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismIntoDirectProduct( diagram, Source( tau[1] ), tau );
        
end );

InstallOtherMethod( UniversalMorphismIntoDirectProduct,
                    [ IsCapCategory, IsList, IsList ],
                    
    function( cat, diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismIntoDirectProduct( cat, diagram, Source( tau[1] ), tau );
        
end );

InstallOtherMethod( UniversalMorphismIntoDirectProductWithGivenDirectProduct,
                    [ IsList, IsList, IsCapCategoryObject ],
                    
    function( diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismIntoDirectProductWithGivenDirectProduct( diagram, Source( tau[1] ), tau, P );
        
end );

InstallOtherMethod( UniversalMorphismIntoDirectProductWithGivenDirectProduct,
                    [ IsCapCategory, IsList, IsList, IsCapCategoryObject ],
                    
    function( cat, diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismIntoDirectProductWithGivenDirectProduct( cat, diagram, Source( tau[1] ), tau, P );
        
end );

##
InstallMethod( AddUniversalMorphismIntoDirectProduct,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoDirectProduct with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau } -> func( cat, diagram, tau );
            
        fi;
        
    else
        
        if nr_arguments = 2 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoDirectProduct with a function with 2 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 3 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau } -> func( diagram, tau );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismIntoDirectProduct( category, wrapper );
    
end );

##
InstallMethod( AddUniversalMorphismIntoDirectProductWithGivenDirectProduct,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 4 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoDirectProductWithGivenDirectProduct with a function with 4 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 5 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau, P } -> func( cat, diagram, tau, P );
            
        fi;
        
    else
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoDirectProductWithGivenDirectProduct with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau, P } -> func( diagram, tau, P );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismIntoDirectProductWithGivenDirectProduct( category, wrapper );
    
end );

##
InstallMethod( UniversalMorphismFromCoproduct,
               [ IsList ],
               
  function( list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismFromCoproduct( CapCategory( list[1] ), list );
    
end );

##
InstallOtherMethod( UniversalMorphismFromCoproduct,
               [ IsCapCategory, IsList ],
               
  function( cat, list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismFromCoproduct( cat, List( list, Source ), list );
    
end );

##
InstallOtherMethod( UniversalMorphismFromCoproduct,
               [ IsCapCategoryObject, IsList ],
               
  function( test_object, list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismFromCoproduct( CapCategory( test_object ), test_object, list );
    
end );

##
InstallOtherMethod( UniversalMorphismFromCoproduct,
               [ IsCapCategory, IsCapCategoryObject, IsList ],
               
  function( cat, test_object, list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismFromCoproduct( cat, List( list, Source ), test_object, list );
    
end );

##
InstallOtherMethod( UniversalMorphismFromCoproduct,
               [ IsCapCategoryMorphism ],
               
  function( mor1 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismFromCoproduct( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismFromCoproduct( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismFromCoproduct( [ mor1 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismFromCoproduct,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismFromCoproduct( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismFromCoproduct( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismFromCoproduct( [ mor1, mor2 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismFromCoproduct,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismFromCoproduct( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismFromCoproduct( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismFromCoproduct( [ mor1, mor2, mor3 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismFromCoproduct,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3, mor4 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismFromCoproduct( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismFromCoproduct( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismFromCoproduct( [ mor1, mor2, mor3, mor4 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismFromCoproduct,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3, mor4, mor5 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismFromCoproduct( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismFromCoproduct( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismFromCoproduct( [ mor1, mor2, mor3, mor4, mor5 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismFromCoproduct,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3, mor4, mor5, mor6 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismFromCoproduct( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismFromCoproduct( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismFromCoproduct( [ mor1, mor2, mor3, mor4, mor5, mor6 ] );
    
end );

InstallOtherMethod( UniversalMorphismFromCoproduct,
                    [ IsList, IsList ],
                    
    function( diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismFromCoproduct( diagram, Range( tau[1] ), tau );
        
end );

InstallOtherMethod( UniversalMorphismFromCoproduct,
                    [ IsCapCategory, IsList, IsList ],
                    
    function( cat, diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismFromCoproduct( cat, diagram, Range( tau[1] ), tau );
        
end );

InstallOtherMethod( UniversalMorphismFromCoproductWithGivenCoproduct,
                    [ IsList, IsList, IsCapCategoryObject ],
                    
    function( diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismFromCoproductWithGivenCoproduct( diagram, Range( tau[1] ), tau, P );
        
end );

InstallOtherMethod( UniversalMorphismFromCoproductWithGivenCoproduct,
                    [ IsCapCategory, IsList, IsList, IsCapCategoryObject ],
                    
    function( cat, diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismFromCoproductWithGivenCoproduct( cat, diagram, Range( tau[1] ), tau, P );
        
end );

##
InstallMethod( AddUniversalMorphismFromCoproduct,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromCoproduct with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau } -> func( cat, diagram, tau );
            
        fi;
        
    else
        
        if nr_arguments = 2 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromCoproduct with a function with 2 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 3 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau } -> func( diagram, tau );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismFromCoproduct( category, wrapper );
    
end );

##
InstallMethod( AddUniversalMorphismFromCoproductWithGivenCoproduct,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 4 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromCoproductWithGivenCoproduct with a function with 4 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 5 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau, P } -> func( cat, diagram, tau, P );
            
        fi;
        
    else
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromCoproductWithGivenCoproduct with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau, P } -> func( diagram, tau, P );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismFromCoproductWithGivenCoproduct( category, wrapper );
    
end );

##
InstallMethod( DirectProductFunctorial,
               [ IsList ],
               
  function( L )
    
    return DirectProductFunctorialWithGivenDirectProducts(
        DirectProduct( List( L, Source ) ),
        List( L, Source ), L, List( L, Range ),
        DirectProduct( List( L, Range ) )
    );
    
end );

##
InstallOtherMethod( DirectProductFunctorial,
               [ IsCapCategory, IsList ],
               
  function( cat, L )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return DirectProductFunctorialWithGivenDirectProducts(
        cat,
        DirectProduct( cat, List( L, Source ) ),
        List( L, Source ), L, List( L, Range ),
        DirectProduct( cat, List( L, Range ) )
    );
    
end );

##
InstallOtherMethod( DirectProductFunctorialWithGivenDirectProducts,
               [ IsCapCategoryObject, IsList, IsCapCategoryObject ],
               
  function( source, L, range )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return DirectProductFunctorialWithGivenDirectProducts(
        source,
        List( L, Source ), L, List( L, Range ),
        range
    );
    
end );

##
InstallOtherMethod( DirectProductFunctorialWithGivenDirectProducts,
               [ IsCapCategory, IsCapCategoryObject, IsList, IsCapCategoryObject ],
               
  function( cat, source, L, range )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return DirectProductFunctorialWithGivenDirectProducts(
        cat,
        source,
        List( L, Source ), L, List( L, Range ),
        range
    );
    
end );

##
InstallMethod( CoproductFunctorial,
               [ IsList ],
               
  function( L )
    
    return CoproductFunctorialWithGivenCoproducts(
        Coproduct( List( L, Source ) ),
        List( L, Source ), L, List( L, Range ),
        Coproduct( List( L, Range ) )
    );
    
end );

##
InstallOtherMethod( CoproductFunctorial,
               [ IsCapCategory, IsList ],
               
  function( cat, L )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return CoproductFunctorialWithGivenCoproducts(
        cat,
        Coproduct( cat, List( L, Source ) ),
        List( L, Source ), L, List( L, Range ),
        Coproduct( cat, List( L, Range ) )
    );
    
end );

##
InstallOtherMethod( CoproductFunctorialWithGivenCoproducts,
               [ IsCapCategoryObject, IsList, IsCapCategoryObject ],
               
  function( source, L, range )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return CoproductFunctorialWithGivenCoproducts(
        source,
        List( L, Source ), L, List( L, Range ),
        range
    );
    
end );

##
InstallOtherMethod( CoproductFunctorialWithGivenCoproducts,
               [ IsCapCategory, IsCapCategoryObject, IsList, IsCapCategoryObject ],
               
  function( cat, source, L, range )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return CoproductFunctorialWithGivenCoproducts(
        cat,
        source,
        List( L, Source ), L, List( L, Range ),
        range
    );
    
end );

##
AddDerivationToCAP( ProjectionInFactorOfDirectSumWithGivenDirectSum,
                    [ [ ProjectionInFactorOfDirectSum, 1 ] ],
  function( cat, objects, k, with_given_object )
    
    return ProjectionInFactorOfDirectSum( cat, objects, k );
    
end : Description := "ProjectionInFactorOfDirectSumWithGivenDirectSum by calling ProjectionInFactorOfDirectSum with the last argument dropped" );

##
AddDerivationToCAP( ProjectionInFactorOfDirectSum,
                    [ [ ProjectionInFactorOfDirectSumWithGivenDirectSum, 1 ],
                      [ DirectSum, 1 ] ],
  function( cat, objects, k )
    
    return ProjectionInFactorOfDirectSumWithGivenDirectSum( cat, objects, k, DirectSum( cat, objects ) );
    
end : Description := "ProjectionInFactorOfDirectSum by calling ProjectionInFactorOfDirectSumWithGivenDirectSum with DirectSum as last argument" );

##
AddDerivationToCAP( UniversalMorphismIntoDirectSumWithGivenDirectSum,
                    [ [ UniversalMorphismIntoDirectSum, 1 ] ],
  function( cat, objects, T, tau, with_given_object )
    
    return UniversalMorphismIntoDirectSum( cat, objects, T, tau );
    
end : Description := "UniversalMorphismIntoDirectSumWithGivenDirectSum by calling UniversalMorphismIntoDirectSum with the last argument dropped" );

##
AddDerivationToCAP( UniversalMorphismIntoDirectSum,
                    [ [ UniversalMorphismIntoDirectSumWithGivenDirectSum, 1 ],
                      [ DirectSum, 1 ] ],
  function( cat, objects, T, tau )
    
    return UniversalMorphismIntoDirectSumWithGivenDirectSum( cat, objects, T, tau, DirectSum( cat, objects ) );
    
end : Description := "UniversalMorphismIntoDirectSum by calling UniversalMorphismIntoDirectSumWithGivenDirectSum with DirectSum as last argument" );

##
AddDerivationToCAP( InjectionOfCofactorOfDirectSumWithGivenDirectSum,
                    [ [ InjectionOfCofactorOfDirectSum, 1 ] ],
  function( cat, objects, k, with_given_object )
    
    return InjectionOfCofactorOfDirectSum( cat, objects, k );
    
end : Description := "InjectionOfCofactorOfDirectSumWithGivenDirectSum by calling InjectionOfCofactorOfDirectSum with the last argument dropped" );

##
AddDerivationToCAP( InjectionOfCofactorOfDirectSum,
                    [ [ InjectionOfCofactorOfDirectSumWithGivenDirectSum, 1 ],
                      [ DirectSum, 1 ] ],
  function( cat, objects, k )
    
    return InjectionOfCofactorOfDirectSumWithGivenDirectSum( cat, objects, k, DirectSum( cat, objects ) );
    
end : Description := "InjectionOfCofactorOfDirectSum by calling InjectionOfCofactorOfDirectSumWithGivenDirectSum with DirectSum as last argument" );

##
AddDerivationToCAP( UniversalMorphismFromDirectSumWithGivenDirectSum,
                    [ [ UniversalMorphismFromDirectSum, 1 ] ],
  function( cat, objects, T, tau, with_given_object )
    
    return UniversalMorphismFromDirectSum( cat, objects, T, tau );
    
end : Description := "UniversalMorphismFromDirectSumWithGivenDirectSum by calling UniversalMorphismFromDirectSum with the last argument dropped" );

##
AddDerivationToCAP( UniversalMorphismFromDirectSum,
                    [ [ UniversalMorphismFromDirectSumWithGivenDirectSum, 1 ],
                      [ DirectSum, 1 ] ],
  function( cat, objects, T, tau )
    
    return UniversalMorphismFromDirectSumWithGivenDirectSum( cat, objects, T, tau, DirectSum( cat, objects ) );
    
end : Description := "UniversalMorphismFromDirectSum by calling UniversalMorphismFromDirectSumWithGivenDirectSum with DirectSum as last argument" );

##
InstallMethod( UniversalMorphismIntoDirectSum,
               [ IsList ],
               
  function( list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismIntoDirectSum( CapCategory( list[1] ), list );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectSum,
               [ IsCapCategory, IsList ],
               
  function( cat, list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismIntoDirectSum( cat, List( list, Range ), list );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectSum,
               [ IsCapCategoryObject, IsList ],
               
  function( test_object, list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismIntoDirectSum( CapCategory( test_object ), test_object, list );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectSum,
               [ IsCapCategory, IsCapCategoryObject, IsList ],
               
  function( cat, test_object, list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismIntoDirectSum( cat, List( list, Range ), test_object, list );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectSum,
               [ IsCapCategoryMorphism ],
               
  function( mor1 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismIntoDirectSum( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismIntoDirectSum( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismIntoDirectSum( [ mor1 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectSum,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismIntoDirectSum( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismIntoDirectSum( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismIntoDirectSum( [ mor1, mor2 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectSum,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismIntoDirectSum( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismIntoDirectSum( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismIntoDirectSum( [ mor1, mor2, mor3 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectSum,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3, mor4 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismIntoDirectSum( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismIntoDirectSum( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismIntoDirectSum( [ mor1, mor2, mor3, mor4 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectSum,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3, mor4, mor5 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismIntoDirectSum( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismIntoDirectSum( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismIntoDirectSum( [ mor1, mor2, mor3, mor4, mor5 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismIntoDirectSum,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3, mor4, mor5, mor6 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismIntoDirectSum( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismIntoDirectSum( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismIntoDirectSum( [ mor1, mor2, mor3, mor4, mor5, mor6 ] );
    
end );

InstallOtherMethod( UniversalMorphismIntoDirectSum,
                    [ IsList, IsList ],
                    
    function( diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismIntoDirectSum( diagram, Source( tau[1] ), tau );
        
end );

InstallOtherMethod( UniversalMorphismIntoDirectSum,
                    [ IsCapCategory, IsList, IsList ],
                    
    function( cat, diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismIntoDirectSum( cat, diagram, Source( tau[1] ), tau );
        
end );

InstallOtherMethod( UniversalMorphismIntoDirectSumWithGivenDirectSum,
                    [ IsList, IsList, IsCapCategoryObject ],
                    
    function( diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismIntoDirectSumWithGivenDirectSum( diagram, Source( tau[1] ), tau, P );
        
end );

InstallOtherMethod( UniversalMorphismIntoDirectSumWithGivenDirectSum,
                    [ IsCapCategory, IsList, IsList, IsCapCategoryObject ],
                    
    function( cat, diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismIntoDirectSumWithGivenDirectSum( cat, diagram, Source( tau[1] ), tau, P );
        
end );

##
InstallMethod( AddUniversalMorphismIntoDirectSum,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoDirectSum with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau } -> func( cat, diagram, tau );
            
        fi;
        
    else
        
        if nr_arguments = 2 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoDirectSum with a function with 2 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 3 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau } -> func( diagram, tau );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismIntoDirectSum( category, wrapper );
    
end );

##
InstallMethod( AddUniversalMorphismIntoDirectSumWithGivenDirectSum,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 4 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoDirectSumWithGivenDirectSum with a function with 4 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 5 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau, P } -> func( cat, diagram, tau, P );
            
        fi;
        
    else
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoDirectSumWithGivenDirectSum with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau, P } -> func( diagram, tau, P );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismIntoDirectSumWithGivenDirectSum( category, wrapper );
    
end );

##
InstallMethod( UniversalMorphismFromDirectSum,
               [ IsList ],
               
  function( list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismFromDirectSum( CapCategory( list[1] ), list );
    
end );

##
InstallOtherMethod( UniversalMorphismFromDirectSum,
               [ IsCapCategory, IsList ],
               
  function( cat, list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismFromDirectSum( cat, List( list, Source ), list );
    
end );

##
InstallOtherMethod( UniversalMorphismFromDirectSum,
               [ IsCapCategoryObject, IsList ],
               
  function( test_object, list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismFromDirectSum( CapCategory( test_object ), test_object, list );
    
end );

##
InstallOtherMethod( UniversalMorphismFromDirectSum,
               [ IsCapCategory, IsCapCategoryObject, IsList ],
               
  function( cat, test_object, list )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return UniversalMorphismFromDirectSum( cat, List( list, Source ), test_object, list );
    
end );

##
InstallOtherMethod( UniversalMorphismFromDirectSum,
               [ IsCapCategoryMorphism ],
               
  function( mor1 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismFromDirectSum( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismFromDirectSum( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismFromDirectSum( [ mor1 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismFromDirectSum,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismFromDirectSum( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismFromDirectSum( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismFromDirectSum( [ mor1, mor2 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismFromDirectSum,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismFromDirectSum( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismFromDirectSum( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismFromDirectSum( [ mor1, mor2, mor3 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismFromDirectSum,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3, mor4 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismFromDirectSum( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismFromDirectSum( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismFromDirectSum( [ mor1, mor2, mor3, mor4 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismFromDirectSum,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3, mor4, mor5 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismFromDirectSum( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismFromDirectSum( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismFromDirectSum( [ mor1, mor2, mor3, mor4, mor5 ] );
    
end );

##
InstallOtherMethod( UniversalMorphismFromDirectSum,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( mor1, mor2, mor3, mor4, mor5, mor6 )
    
    Print(
      Concatenation(
      "WARNING: UniversalMorphismFromDirectSum( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. ",
      "Please use UniversalMorphismFromDirectSum( [ IsCapCategoryMorphism, ... ] ) instead.\n"
      )
    );
    
    return UniversalMorphismFromDirectSum( [ mor1, mor2, mor3, mor4, mor5, mor6 ] );
    
end );

InstallOtherMethod( UniversalMorphismFromDirectSum,
                    [ IsList, IsList ],
                    
    function( diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismFromDirectSum( diagram, Range( tau[1] ), tau );
        
end );

InstallOtherMethod( UniversalMorphismFromDirectSum,
                    [ IsCapCategory, IsList, IsList ],
                    
    function( cat, diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismFromDirectSum( cat, diagram, Range( tau[1] ), tau );
        
end );

InstallOtherMethod( UniversalMorphismFromDirectSumWithGivenDirectSum,
                    [ IsList, IsList, IsCapCategoryObject ],
                    
    function( diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismFromDirectSumWithGivenDirectSum( diagram, Range( tau[1] ), tau, P );
        
end );

InstallOtherMethod( UniversalMorphismFromDirectSumWithGivenDirectSum,
                    [ IsCapCategory, IsList, IsList, IsCapCategoryObject ],
                    
    function( cat, diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismFromDirectSumWithGivenDirectSum( cat, diagram, Range( tau[1] ), tau, P );
        
end );

##
InstallMethod( AddUniversalMorphismFromDirectSum,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromDirectSum with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau } -> func( cat, diagram, tau );
            
        fi;
        
    else
        
        if nr_arguments = 2 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromDirectSum with a function with 2 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 3 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau } -> func( diagram, tau );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismFromDirectSum( category, wrapper );
    
end );

##
InstallMethod( AddUniversalMorphismFromDirectSumWithGivenDirectSum,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 4 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromDirectSumWithGivenDirectSum with a function with 4 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 5 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau, P } -> func( cat, diagram, tau, P );
            
        fi;
        
    else
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromDirectSumWithGivenDirectSum with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau, P } -> func( diagram, tau, P );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismFromDirectSumWithGivenDirectSum( category, wrapper );
    
end );

##
InstallMethod( DirectSumFunctorial,
               [ IsList ],
               
  function( L )
    
    return DirectSumFunctorialWithGivenDirectSums(
        DirectSum( List( L, Source ) ),
        List( L, Source ), L, List( L, Range ),
        DirectSum( List( L, Range ) )
    );
    
end );

##
InstallOtherMethod( DirectSumFunctorial,
               [ IsCapCategory, IsList ],
               
  function( cat, L )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return DirectSumFunctorialWithGivenDirectSums(
        cat,
        DirectSum( cat, List( L, Source ) ),
        List( L, Source ), L, List( L, Range ),
        DirectSum( cat, List( L, Range ) )
    );
    
end );

##
InstallOtherMethod( DirectSumFunctorialWithGivenDirectSums,
               [ IsCapCategoryObject, IsList, IsCapCategoryObject ],
               
  function( source, L, range )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return DirectSumFunctorialWithGivenDirectSums(
        source,
        List( L, Source ), L, List( L, Range ),
        range
    );
    
end );

##
InstallOtherMethod( DirectSumFunctorialWithGivenDirectSums,
               [ IsCapCategory, IsCapCategoryObject, IsList, IsCapCategoryObject ],
               
  function( cat, source, L, range )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return DirectSumFunctorialWithGivenDirectSums(
        cat,
        source,
        List( L, Source ), L, List( L, Range ),
        range
    );
    
end );

##
AddDerivationToCAP( ProjectionInFactorOfFiberProductWithGivenFiberProduct,
                    [ [ ProjectionInFactorOfFiberProduct, 1 ] ],
  function( cat, morphisms, k, with_given_object )
    
    return ProjectionInFactorOfFiberProduct( cat, morphisms, k );
    
end : Description := "ProjectionInFactorOfFiberProductWithGivenFiberProduct by calling ProjectionInFactorOfFiberProduct with the last argument dropped" );

##
AddDerivationToCAP( ProjectionInFactorOfFiberProduct,
                    [ [ ProjectionInFactorOfFiberProductWithGivenFiberProduct, 1 ],
                      [ FiberProduct, 1 ] ],
  function( cat, morphisms, k )
    
    return ProjectionInFactorOfFiberProductWithGivenFiberProduct( cat, morphisms, k, FiberProduct( cat, morphisms ) );
    
end : Description := "ProjectionInFactorOfFiberProduct by calling ProjectionInFactorOfFiberProductWithGivenFiberProduct with FiberProduct as last argument" );

##
AddDerivationToCAP( MorphismFromFiberProductToSinkWithGivenFiberProduct,
                    [ [ MorphismFromFiberProductToSink, 1 ] ],
  function( cat, morphisms, with_given_object )
    
    return MorphismFromFiberProductToSink( cat, morphisms );
    
end : Description := "MorphismFromFiberProductToSinkWithGivenFiberProduct by calling MorphismFromFiberProductToSink with the last argument dropped" );

##
AddDerivationToCAP( MorphismFromFiberProductToSink,
                    [ [ MorphismFromFiberProductToSinkWithGivenFiberProduct, 1 ],
                      [ FiberProduct, 1 ] ],
  function( cat, morphisms )
    
    return MorphismFromFiberProductToSinkWithGivenFiberProduct( cat, morphisms, FiberProduct( cat, morphisms ) );
    
end : Description := "MorphismFromFiberProductToSink by calling MorphismFromFiberProductToSinkWithGivenFiberProduct with FiberProduct as last argument" );

##
AddDerivationToCAP( UniversalMorphismIntoFiberProductWithGivenFiberProduct,
                    [ [ UniversalMorphismIntoFiberProduct, 1 ] ],
  function( cat, morphisms, T, tau, with_given_object )
    
    return UniversalMorphismIntoFiberProduct( cat, morphisms, T, tau );
    
end : Description := "UniversalMorphismIntoFiberProductWithGivenFiberProduct by calling UniversalMorphismIntoFiberProduct with the last argument dropped" );

##
AddDerivationToCAP( UniversalMorphismIntoFiberProduct,
                    [ [ UniversalMorphismIntoFiberProductWithGivenFiberProduct, 1 ],
                      [ FiberProduct, 1 ] ],
  function( cat, morphisms, T, tau )
    
    return UniversalMorphismIntoFiberProductWithGivenFiberProduct( cat, morphisms, T, tau, FiberProduct( cat, morphisms ) );
    
end : Description := "UniversalMorphismIntoFiberProduct by calling UniversalMorphismIntoFiberProductWithGivenFiberProduct with FiberProduct as last argument" );

##
AddDerivationToCAP( InjectionOfCofactorOfPushoutWithGivenPushout,
                    [ [ InjectionOfCofactorOfPushout, 1 ] ],
  function( cat, morphisms, k, with_given_object )
    
    return InjectionOfCofactorOfPushout( cat, morphisms, k );
    
end : Description := "InjectionOfCofactorOfPushoutWithGivenPushout by calling InjectionOfCofactorOfPushout with the last argument dropped" );

##
AddDerivationToCAP( InjectionOfCofactorOfPushout,
                    [ [ InjectionOfCofactorOfPushoutWithGivenPushout, 1 ],
                      [ Pushout, 1 ] ],
  function( cat, morphisms, k )
    
    return InjectionOfCofactorOfPushoutWithGivenPushout( cat, morphisms, k, Pushout( cat, morphisms ) );
    
end : Description := "InjectionOfCofactorOfPushout by calling InjectionOfCofactorOfPushoutWithGivenPushout with Pushout as last argument" );

##
AddDerivationToCAP( MorphismFromSourceToPushoutWithGivenPushout,
                    [ [ MorphismFromSourceToPushout, 1 ] ],
  function( cat, morphisms, with_given_object )
    
    return MorphismFromSourceToPushout( cat, morphisms );
    
end : Description := "MorphismFromSourceToPushoutWithGivenPushout by calling MorphismFromSourceToPushout with the last argument dropped" );

##
AddDerivationToCAP( MorphismFromSourceToPushout,
                    [ [ MorphismFromSourceToPushoutWithGivenPushout, 1 ],
                      [ Pushout, 1 ] ],
  function( cat, morphisms )
    
    return MorphismFromSourceToPushoutWithGivenPushout( cat, morphisms, Pushout( cat, morphisms ) );
    
end : Description := "MorphismFromSourceToPushout by calling MorphismFromSourceToPushoutWithGivenPushout with Pushout as last argument" );

##
AddDerivationToCAP( UniversalMorphismFromPushoutWithGivenPushout,
                    [ [ UniversalMorphismFromPushout, 1 ] ],
  function( cat, morphisms, T, tau, with_given_object )
    
    return UniversalMorphismFromPushout( cat, morphisms, T, tau );
    
end : Description := "UniversalMorphismFromPushoutWithGivenPushout by calling UniversalMorphismFromPushout with the last argument dropped" );

##
AddDerivationToCAP( UniversalMorphismFromPushout,
                    [ [ UniversalMorphismFromPushoutWithGivenPushout, 1 ],
                      [ Pushout, 1 ] ],
  function( cat, morphisms, T, tau )
    
    return UniversalMorphismFromPushoutWithGivenPushout( cat, morphisms, T, tau, Pushout( cat, morphisms ) );
    
end : Description := "UniversalMorphismFromPushout by calling UniversalMorphismFromPushoutWithGivenPushout with Pushout as last argument" );

##
InstallMethod( AddUniversalMorphismIntoFiberProduct,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoFiberProduct with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau } -> func( cat, diagram, tau );
            
        fi;
        
    else
        
        if nr_arguments = 2 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoFiberProduct with a function with 2 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 3 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau } -> func( diagram, tau );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismIntoFiberProduct( category, wrapper );
    
end );

##
InstallMethod( AddUniversalMorphismIntoFiberProductWithGivenFiberProduct,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 4 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoFiberProductWithGivenFiberProduct with a function with 4 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 5 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau, P } -> func( cat, diagram, tau, P );
            
        fi;
        
    else
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoFiberProductWithGivenFiberProduct with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau, P } -> func( diagram, tau, P );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismIntoFiberProductWithGivenFiberProduct( category, wrapper );
    
end );

##
InstallMethod( AddUniversalMorphismFromPushout,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromPushout with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau } -> func( cat, diagram, tau );
            
        fi;
        
    else
        
        if nr_arguments = 2 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromPushout with a function with 2 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 3 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau } -> func( diagram, tau );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismFromPushout( category, wrapper );
    
end );

##
InstallMethod( AddUniversalMorphismFromPushoutWithGivenPushout,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 4 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromPushoutWithGivenPushout with a function with 4 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 5 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau, P } -> func( cat, diagram, tau, P );
            
        fi;
        
    else
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromPushoutWithGivenPushout with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau, P } -> func( diagram, tau, P );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismFromPushoutWithGivenPushout( category, wrapper );
    
end );

##
InstallMethod( FiberProductFunctorial,
               [ IsList, IsList, IsList ],
               
  function( morphisms, L, morphismsp )
    
    return FiberProductFunctorialWithGivenFiberProducts(
        FiberProduct( morphisms ),
        morphisms, L, morphismsp,
        FiberProduct( morphismsp )
    );
    
end );

##
InstallOtherMethod( FiberProductFunctorial,
               [ IsCapCategory, IsList, IsList, IsList ],
               
  function( cat, morphisms, L, morphismsp )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return FiberProductFunctorialWithGivenFiberProducts(
        cat,
        FiberProduct( cat, morphisms ),
        morphisms, L, morphismsp,
        FiberProduct( cat, morphismsp )
    );
    
end );

##
InstallMethod( PushoutFunctorial,
               [ IsList, IsList, IsList ],
               
  function( morphisms, L, morphismsp )
    
    return PushoutFunctorialWithGivenPushouts(
        Pushout( morphisms ),
        morphisms, L, morphismsp,
        Pushout( morphismsp )
    );
    
end );

##
InstallOtherMethod( PushoutFunctorial,
               [ IsCapCategory, IsList, IsList, IsList ],
               
  function( cat, morphisms, L, morphismsp )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return PushoutFunctorialWithGivenPushouts(
        cat,
        Pushout( cat, morphisms ),
        morphisms, L, morphismsp,
        Pushout( cat, morphismsp )
    );
    
end );

##
AddDerivationToCAP( EmbeddingOfEqualizerWithGivenEqualizer,
                    [ [ EmbeddingOfEqualizer, 1 ] ],
  function( cat, morphisms, with_given_object )
    
    return EmbeddingOfEqualizer( cat, morphisms );
    
end : Description := "EmbeddingOfEqualizerWithGivenEqualizer by calling EmbeddingOfEqualizer with the last argument dropped" );

##
AddDerivationToCAP( EmbeddingOfEqualizer,
                    [ [ EmbeddingOfEqualizerWithGivenEqualizer, 1 ],
                      [ Equalizer, 1 ] ],
  function( cat, morphisms )
    
    return EmbeddingOfEqualizerWithGivenEqualizer( cat, morphisms, Equalizer( cat, morphisms ) );
    
end : Description := "EmbeddingOfEqualizer by calling EmbeddingOfEqualizerWithGivenEqualizer with Equalizer as last argument" );

##
AddDerivationToCAP( MorphismFromEqualizerToSinkWithGivenEqualizer,
                    [ [ MorphismFromEqualizerToSink, 1 ] ],
  function( cat, morphisms, with_given_object )
    
    return MorphismFromEqualizerToSink( cat, morphisms );
    
end : Description := "MorphismFromEqualizerToSinkWithGivenEqualizer by calling MorphismFromEqualizerToSink with the last argument dropped" );

##
AddDerivationToCAP( MorphismFromEqualizerToSink,
                    [ [ MorphismFromEqualizerToSinkWithGivenEqualizer, 1 ],
                      [ Equalizer, 1 ] ],
  function( cat, morphisms )
    
    return MorphismFromEqualizerToSinkWithGivenEqualizer( cat, morphisms, Equalizer( cat, morphisms ) );
    
end : Description := "MorphismFromEqualizerToSink by calling MorphismFromEqualizerToSinkWithGivenEqualizer with Equalizer as last argument" );

##
AddDerivationToCAP( UniversalMorphismIntoEqualizerWithGivenEqualizer,
                    [ [ UniversalMorphismIntoEqualizer, 1 ] ],
  function( cat, morphisms, T, tau, with_given_object )
    
    return UniversalMorphismIntoEqualizer( cat, morphisms, T, tau );
    
end : Description := "UniversalMorphismIntoEqualizerWithGivenEqualizer by calling UniversalMorphismIntoEqualizer with the last argument dropped" );

##
AddDerivationToCAP( UniversalMorphismIntoEqualizer,
                    [ [ UniversalMorphismIntoEqualizerWithGivenEqualizer, 1 ],
                      [ Equalizer, 1 ] ],
  function( cat, morphisms, T, tau )
    
    return UniversalMorphismIntoEqualizerWithGivenEqualizer( cat, morphisms, T, tau, Equalizer( cat, morphisms ) );
    
end : Description := "UniversalMorphismIntoEqualizer by calling UniversalMorphismIntoEqualizerWithGivenEqualizer with Equalizer as last argument" );

##
AddDerivationToCAP( ProjectionOntoCoequalizerWithGivenCoequalizer,
                    [ [ ProjectionOntoCoequalizer, 1 ] ],
  function( cat, morphisms, with_given_object )
    
    return ProjectionOntoCoequalizer( cat, morphisms );
    
end : Description := "ProjectionOntoCoequalizerWithGivenCoequalizer by calling ProjectionOntoCoequalizer with the last argument dropped" );

##
AddDerivationToCAP( ProjectionOntoCoequalizer,
                    [ [ ProjectionOntoCoequalizerWithGivenCoequalizer, 1 ],
                      [ Coequalizer, 1 ] ],
  function( cat, morphisms )
    
    return ProjectionOntoCoequalizerWithGivenCoequalizer( cat, morphisms, Coequalizer( cat, morphisms ) );
    
end : Description := "ProjectionOntoCoequalizer by calling ProjectionOntoCoequalizerWithGivenCoequalizer with Coequalizer as last argument" );

##
AddDerivationToCAP( MorphismFromSourceToCoequalizerWithGivenCoequalizer,
                    [ [ MorphismFromSourceToCoequalizer, 1 ] ],
  function( cat, morphisms, with_given_object )
    
    return MorphismFromSourceToCoequalizer( cat, morphisms );
    
end : Description := "MorphismFromSourceToCoequalizerWithGivenCoequalizer by calling MorphismFromSourceToCoequalizer with the last argument dropped" );

##
AddDerivationToCAP( MorphismFromSourceToCoequalizer,
                    [ [ MorphismFromSourceToCoequalizerWithGivenCoequalizer, 1 ],
                      [ Coequalizer, 1 ] ],
  function( cat, morphisms )
    
    return MorphismFromSourceToCoequalizerWithGivenCoequalizer( cat, morphisms, Coequalizer( cat, morphisms ) );
    
end : Description := "MorphismFromSourceToCoequalizer by calling MorphismFromSourceToCoequalizerWithGivenCoequalizer with Coequalizer as last argument" );

##
AddDerivationToCAP( UniversalMorphismFromCoequalizerWithGivenCoequalizer,
                    [ [ UniversalMorphismFromCoequalizer, 1 ] ],
  function( cat, morphisms, T, tau, with_given_object )
    
    return UniversalMorphismFromCoequalizer( cat, morphisms, T, tau );
    
end : Description := "UniversalMorphismFromCoequalizerWithGivenCoequalizer by calling UniversalMorphismFromCoequalizer with the last argument dropped" );

##
AddDerivationToCAP( UniversalMorphismFromCoequalizer,
                    [ [ UniversalMorphismFromCoequalizerWithGivenCoequalizer, 1 ],
                      [ Coequalizer, 1 ] ],
  function( cat, morphisms, T, tau )
    
    return UniversalMorphismFromCoequalizerWithGivenCoequalizer( cat, morphisms, T, tau, Coequalizer( cat, morphisms ) );
    
end : Description := "UniversalMorphismFromCoequalizer by calling UniversalMorphismFromCoequalizerWithGivenCoequalizer with Coequalizer as last argument" );

InstallOtherMethod( UniversalMorphismIntoEqualizer,
                    [ IsList, IsCapCategoryMorphism ],
                    
    function( diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismIntoEqualizer( diagram, Source( tau ), tau );
        
end );

InstallOtherMethod( UniversalMorphismIntoEqualizer,
                    [ IsCapCategory, IsList, IsCapCategoryMorphism ],
                    
    function( cat, diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismIntoEqualizer( cat, diagram, Source( tau ), tau );
        
end );

InstallOtherMethod( UniversalMorphismIntoEqualizerWithGivenEqualizer,
                    [ IsList, IsCapCategoryMorphism, IsCapCategoryObject ],
                    
    function( diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismIntoEqualizerWithGivenEqualizer( diagram, Source( tau ), tau, P );
        
end );

InstallOtherMethod( UniversalMorphismIntoEqualizerWithGivenEqualizer,
                    [ IsCapCategory, IsList, IsCapCategoryMorphism, IsCapCategoryObject ],
                    
    function( cat, diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismIntoEqualizerWithGivenEqualizer( cat, diagram, Source( tau ), tau, P );
        
end );

##
InstallMethod( AddUniversalMorphismIntoEqualizer,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoEqualizer with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau } -> func( cat, diagram, tau );
            
        fi;
        
    else
        
        if nr_arguments = 2 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoEqualizer with a function with 2 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 3 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau } -> func( diagram, tau );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismIntoEqualizer( category, wrapper );
    
end );

##
InstallMethod( AddUniversalMorphismIntoEqualizerWithGivenEqualizer,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 4 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoEqualizerWithGivenEqualizer with a function with 4 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 5 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau, P } -> func( cat, diagram, tau, P );
            
        fi;
        
    else
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismIntoEqualizerWithGivenEqualizer with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau, P } -> func( diagram, tau, P );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismIntoEqualizerWithGivenEqualizer( category, wrapper );
    
end );

InstallOtherMethod( UniversalMorphismFromCoequalizer,
                    [ IsList, IsCapCategoryMorphism ],
                    
    function( diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismFromCoequalizer( diagram, Range( tau ), tau );
        
end );

InstallOtherMethod( UniversalMorphismFromCoequalizer,
                    [ IsCapCategory, IsList, IsCapCategoryMorphism ],
                    
    function( cat, diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismFromCoequalizer( cat, diagram, Range( tau ), tau );
        
end );

InstallOtherMethod( UniversalMorphismFromCoequalizerWithGivenCoequalizer,
                    [ IsList, IsCapCategoryMorphism, IsCapCategoryObject ],
                    
    function( diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismFromCoequalizerWithGivenCoequalizer( diagram, Range( tau ), tau, P );
        
end );

InstallOtherMethod( UniversalMorphismFromCoequalizerWithGivenCoequalizer,
                    [ IsCapCategory, IsList, IsCapCategoryMorphism, IsCapCategoryObject ],
                    
    function( cat, diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return UniversalMorphismFromCoequalizerWithGivenCoequalizer( cat, diagram, Range( tau ), tau, P );
        
end );

##
InstallMethod( AddUniversalMorphismFromCoequalizer,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromCoequalizer with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau } -> func( cat, diagram, tau );
            
        fi;
        
    else
        
        if nr_arguments = 2 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromCoequalizer with a function with 2 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 3 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau } -> func( diagram, tau );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismFromCoequalizer( category, wrapper );
    
end );

##
InstallMethod( AddUniversalMorphismFromCoequalizerWithGivenCoequalizer,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 4 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromCoequalizerWithGivenCoequalizer with a function with 4 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 5 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau, P } -> func( cat, diagram, tau, P );
            
        fi;
        
    else
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddUniversalMorphismFromCoequalizerWithGivenCoequalizer with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau, P } -> func( diagram, tau, P );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddUniversalMorphismFromCoequalizerWithGivenCoequalizer( category, wrapper );
    
end );

##
InstallMethod( EqualizerFunctorial,
               [ IsList, IsCapCategoryMorphism, IsList ],
               
  function( morphisms, mu, morphismsp )
    
    return EqualizerFunctorialWithGivenEqualizers(
        Equalizer( morphisms ),
        morphisms, mu, morphismsp,
        Equalizer( morphismsp )
    );
    
end );

##
InstallOtherMethod( EqualizerFunctorial,
               [ IsCapCategory, IsList, IsCapCategoryMorphism, IsList ],
               
  function( cat, morphisms, mu, morphismsp )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return EqualizerFunctorialWithGivenEqualizers(
        cat,
        Equalizer( cat, morphisms ),
        morphisms, mu, morphismsp,
        Equalizer( cat, morphismsp )
    );
    
end );

##
InstallMethod( CoequalizerFunctorial,
               [ IsList, IsCapCategoryMorphism, IsList ],
               
  function( morphisms, mu, morphismsp )
    
    return CoequalizerFunctorialWithGivenCoequalizers(
        Coequalizer( morphisms ),
        morphisms, mu, morphismsp,
        Coequalizer( morphismsp )
    );
    
end );

##
InstallOtherMethod( CoequalizerFunctorial,
               [ IsCapCategory, IsList, IsCapCategoryMorphism, IsList ],
               
  function( cat, morphisms, mu, morphismsp )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return CoequalizerFunctorialWithGivenCoequalizers(
        cat,
        Coequalizer( cat, morphisms ),
        morphisms, mu, morphismsp,
        Coequalizer( cat, morphismsp )
    );
    
end );

##
AddDerivationToCAP( KernelEmbeddingWithGivenKernelObject,
                    [ [ KernelEmbedding, 1 ] ],
  function( cat, alpha, with_given_object )
    
    return KernelEmbedding( cat, alpha );
    
end : Description := "KernelEmbeddingWithGivenKernelObject by calling KernelEmbedding with the last argument dropped" );

##
AddDerivationToCAP( KernelEmbedding,
                    [ [ KernelEmbeddingWithGivenKernelObject, 1 ],
                      [ KernelObject, 1 ] ],
  function( cat, alpha )
    
    return KernelEmbeddingWithGivenKernelObject( cat, alpha, KernelObject( cat, alpha ) );
    
end : Description := "KernelEmbedding by calling KernelEmbeddingWithGivenKernelObject with KernelObject as last argument" );

##
AddDerivationToCAP( MorphismFromKernelObjectToSinkWithGivenKernelObject,
                    [ [ MorphismFromKernelObjectToSink, 1 ] ],
  function( cat, alpha, with_given_object )
    
    return MorphismFromKernelObjectToSink( cat, alpha );
    
end : Description := "MorphismFromKernelObjectToSinkWithGivenKernelObject by calling MorphismFromKernelObjectToSink with the last argument dropped" );

##
AddDerivationToCAP( MorphismFromKernelObjectToSink,
                    [ [ MorphismFromKernelObjectToSinkWithGivenKernelObject, 1 ],
                      [ KernelObject, 1 ] ],
  function( cat, alpha )
    
    return MorphismFromKernelObjectToSinkWithGivenKernelObject( cat, alpha, KernelObject( cat, alpha ) );
    
end : Description := "MorphismFromKernelObjectToSink by calling MorphismFromKernelObjectToSinkWithGivenKernelObject with KernelObject as last argument" );

##
AddDerivationToCAP( KernelLiftWithGivenKernelObject,
                    [ [ KernelLift, 1 ] ],
  function( cat, alpha, T, tau, with_given_object )
    
    return KernelLift( cat, alpha, T, tau );
    
end : Description := "KernelLiftWithGivenKernelObject by calling KernelLift with the last argument dropped" );

##
AddDerivationToCAP( KernelLift,
                    [ [ KernelLiftWithGivenKernelObject, 1 ],
                      [ KernelObject, 1 ] ],
  function( cat, alpha, T, tau )
    
    return KernelLiftWithGivenKernelObject( cat, alpha, T, tau, KernelObject( cat, alpha ) );
    
end : Description := "KernelLift by calling KernelLiftWithGivenKernelObject with KernelObject as last argument" );

##
AddDerivationToCAP( CokernelProjectionWithGivenCokernelObject,
                    [ [ CokernelProjection, 1 ] ],
  function( cat, alpha, with_given_object )
    
    return CokernelProjection( cat, alpha );
    
end : Description := "CokernelProjectionWithGivenCokernelObject by calling CokernelProjection with the last argument dropped" );

##
AddDerivationToCAP( CokernelProjection,
                    [ [ CokernelProjectionWithGivenCokernelObject, 1 ],
                      [ CokernelObject, 1 ] ],
  function( cat, alpha )
    
    return CokernelProjectionWithGivenCokernelObject( cat, alpha, CokernelObject( cat, alpha ) );
    
end : Description := "CokernelProjection by calling CokernelProjectionWithGivenCokernelObject with CokernelObject as last argument" );

##
AddDerivationToCAP( MorphismFromSourceToCokernelObjectWithGivenCokernelObject,
                    [ [ MorphismFromSourceToCokernelObject, 1 ] ],
  function( cat, alpha, with_given_object )
    
    return MorphismFromSourceToCokernelObject( cat, alpha );
    
end : Description := "MorphismFromSourceToCokernelObjectWithGivenCokernelObject by calling MorphismFromSourceToCokernelObject with the last argument dropped" );

##
AddDerivationToCAP( MorphismFromSourceToCokernelObject,
                    [ [ MorphismFromSourceToCokernelObjectWithGivenCokernelObject, 1 ],
                      [ CokernelObject, 1 ] ],
  function( cat, alpha )
    
    return MorphismFromSourceToCokernelObjectWithGivenCokernelObject( cat, alpha, CokernelObject( cat, alpha ) );
    
end : Description := "MorphismFromSourceToCokernelObject by calling MorphismFromSourceToCokernelObjectWithGivenCokernelObject with CokernelObject as last argument" );

##
AddDerivationToCAP( CokernelColiftWithGivenCokernelObject,
                    [ [ CokernelColift, 1 ] ],
  function( cat, alpha, T, tau, with_given_object )
    
    return CokernelColift( cat, alpha, T, tau );
    
end : Description := "CokernelColiftWithGivenCokernelObject by calling CokernelColift with the last argument dropped" );

##
AddDerivationToCAP( CokernelColift,
                    [ [ CokernelColiftWithGivenCokernelObject, 1 ],
                      [ CokernelObject, 1 ] ],
  function( cat, alpha, T, tau )
    
    return CokernelColiftWithGivenCokernelObject( cat, alpha, T, tau, CokernelObject( cat, alpha ) );
    
end : Description := "CokernelColift by calling CokernelColiftWithGivenCokernelObject with CokernelObject as last argument" );

InstallOtherMethod( KernelLift,
                    [ IsCapCategoryMorphism, IsCapCategoryMorphism ],
                    
    function( diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return KernelLift( diagram, Source( tau ), tau );
        
end );

InstallOtherMethod( KernelLift,
                    [ IsCapCategory, IsCapCategoryMorphism, IsCapCategoryMorphism ],
                    
    function( cat, diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return KernelLift( cat, diagram, Source( tau ), tau );
        
end );

InstallOtherMethod( KernelLiftWithGivenKernelObject,
                    [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryObject ],
                    
    function( diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return KernelLiftWithGivenKernelObject( diagram, Source( tau ), tau, P );
        
end );

InstallOtherMethod( KernelLiftWithGivenKernelObject,
                    [ IsCapCategory, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryObject ],
                    
    function( cat, diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return KernelLiftWithGivenKernelObject( cat, diagram, Source( tau ), tau, P );
        
end );

##
InstallMethod( AddKernelLift,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddKernelLift with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau } -> func( cat, diagram, tau );
            
        fi;
        
    else
        
        if nr_arguments = 2 then
        
            Print(
              Concatenation(
              "WARNING: AddKernelLift with a function with 2 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 3 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau } -> func( diagram, tau );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddKernelLift( category, wrapper );
    
end );

##
InstallMethod( AddKernelLiftWithGivenKernelObject,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 4 then
        
            Print(
              Concatenation(
              "WARNING: AddKernelLiftWithGivenKernelObject with a function with 4 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 5 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau, P } -> func( cat, diagram, tau, P );
            
        fi;
        
    else
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddKernelLiftWithGivenKernelObject with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau, P } -> func( diagram, tau, P );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddKernelLiftWithGivenKernelObject( category, wrapper );
    
end );

InstallOtherMethod( CokernelColift,
                    [ IsCapCategoryMorphism, IsCapCategoryMorphism ],
                    
    function( diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return CokernelColift( diagram, Range( tau ), tau );
        
end );

InstallOtherMethod( CokernelColift,
                    [ IsCapCategory, IsCapCategoryMorphism, IsCapCategoryMorphism ],
                    
    function( cat, diagram, tau )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return CokernelColift( cat, diagram, Range( tau ), tau );
        
end );

InstallOtherMethod( CokernelColiftWithGivenCokernelObject,
                    [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryObject ],
                    
    function( diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return CokernelColiftWithGivenCokernelObject( diagram, Range( tau ), tau, P );
        
end );

InstallOtherMethod( CokernelColiftWithGivenCokernelObject,
                    [ IsCapCategory, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryObject ],
                    
    function( cat, diagram, tau, P )
        #% CAP_JIT_RESOLVE_FUNCTION
        
        return CokernelColiftWithGivenCokernelObject( cat, diagram, Range( tau ), tau, P );
        
end );

##
InstallMethod( AddCokernelColift,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddCokernelColift with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau } -> func( cat, diagram, tau );
            
        fi;
        
    else
        
        if nr_arguments = 2 then
        
            Print(
              Concatenation(
              "WARNING: AddCokernelColift with a function with 2 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 3 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau } -> func( diagram, tau );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddCokernelColift( category, wrapper );
    
end );

##
InstallMethod( AddCokernelColiftWithGivenCokernelObject,
               [ IsCapCategory, IsFunction ],
               
  function( category, func )
    local nr_arguments, wrapper;
    
    nr_arguments := NumberArgumentsFunction( func );
    
    wrapper := fail;
    
    if IsBound( category!.category_as_first_argument ) and category!.category_as_first_argument = true then
        
        if nr_arguments = 4 then
        
            Print(
              Concatenation(
              "WARNING: AddCokernelColiftWithGivenCokernelObject with a function with 4 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 5 arguments instead.\n"
              )
            );
                
            wrapper := { cat, diagram, T, tau, P } -> func( cat, diagram, tau, P );
            
        fi;
        
    else
        
        if nr_arguments = 3 then
        
            Print(
              Concatenation(
              "WARNING: AddCokernelColiftWithGivenCokernelObject with a function with 3 arguments is deprecated and will not be supported after 2022.04.18. ",
              "Please give a function with 4 arguments instead.\n"
              )
            );
                
            wrapper := { diagram, T, tau, P } -> func( diagram, tau, P );
            
        fi;
        
    fi;
    
    if wrapper = fail then
        
        TryNextMethod( );
        
    fi;
    
    AddCokernelColiftWithGivenCokernelObject( category, wrapper );
    
end );

##
InstallMethod( KernelObjectFunctorial,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( alpha, mu, alphap )
    
    return KernelObjectFunctorialWithGivenKernelObjects(
        KernelObject( alpha ),
        alpha, mu, alphap,
        KernelObject( alphap )
    );
    
end );

##
InstallOtherMethod( KernelObjectFunctorial,
               [ IsCapCategory, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( cat, alpha, mu, alphap )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return KernelObjectFunctorialWithGivenKernelObjects(
        cat,
        KernelObject( cat, alpha ),
        alpha, mu, alphap,
        KernelObject( cat, alphap )
    );
    
end );

##
InstallMethod( CokernelObjectFunctorial,
               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( alpha, mu, alphap )
    
    return CokernelObjectFunctorialWithGivenCokernelObjects(
        CokernelObject( alpha ),
        alpha, mu, alphap,
        CokernelObject( alphap )
    );
    
end );

##
InstallOtherMethod( CokernelObjectFunctorial,
               [ IsCapCategory, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],
               
  function( cat, alpha, mu, alphap )
    #% CAP_JIT_RESOLVE_FUNCTION
    
    return CokernelObjectFunctorialWithGivenCokernelObjects(
        cat,
        CokernelObject( cat, alpha ),
        alpha, mu, alphap,
        CokernelObject( cat, alphap )
    );
    
end );

##
AddDerivationToCAP( UniversalMorphismIntoTerminalObjectWithGivenTerminalObject,
                    [ [ UniversalMorphismIntoTerminalObject, 1 ] ],
  function( cat, T, with_given_object )
    
    return UniversalMorphismIntoTerminalObject( cat, T );
    
end : Description := "UniversalMorphismIntoTerminalObjectWithGivenTerminalObject by calling UniversalMorphismIntoTerminalObject with the last argument dropped" );

##
AddDerivationToCAP( UniversalMorphismIntoTerminalObject,
                    [ [ UniversalMorphismIntoTerminalObjectWithGivenTerminalObject, 1 ],
                      [ TerminalObject, 1 ] ],
  function( cat, T )
    
    return UniversalMorphismIntoTerminalObjectWithGivenTerminalObject( cat, T, TerminalObject( cat ) );
    
end : Description := "UniversalMorphismIntoTerminalObject by calling UniversalMorphismIntoTerminalObjectWithGivenTerminalObject with TerminalObject as last argument" );

##
AddDerivationToCAP( UniversalMorphismFromInitialObjectWithGivenInitialObject,
                    [ [ UniversalMorphismFromInitialObject, 1 ] ],
  function( cat, T, with_given_object )
    
    return UniversalMorphismFromInitialObject( cat, T );
    
end : Description := "UniversalMorphismFromInitialObjectWithGivenInitialObject by calling UniversalMorphismFromInitialObject with the last argument dropped" );

##
AddDerivationToCAP( UniversalMorphismFromInitialObject,
                    [ [ UniversalMorphismFromInitialObjectWithGivenInitialObject, 1 ],
                      [ InitialObject, 1 ] ],
  function( cat, T )
    
    return UniversalMorphismFromInitialObjectWithGivenInitialObject( cat, T, InitialObject( cat ) );
    
end : Description := "UniversalMorphismFromInitialObject by calling UniversalMorphismFromInitialObjectWithGivenInitialObject with InitialObject as last argument" );

##
AddDerivationToCAP( UniversalMorphismIntoZeroObjectWithGivenZeroObject,
                    [ [ UniversalMorphismIntoZeroObject, 1 ] ],
  function( cat, T, with_given_object )
    
    return UniversalMorphismIntoZeroObject( cat, T );
    
end : Description := "UniversalMorphismIntoZeroObjectWithGivenZeroObject by calling UniversalMorphismIntoZeroObject with the last argument dropped" );

##
AddDerivationToCAP( UniversalMorphismIntoZeroObject,
                    [ [ UniversalMorphismIntoZeroObjectWithGivenZeroObject, 1 ],
                      [ ZeroObject, 1 ] ],
  function( cat, T )
    
    return UniversalMorphismIntoZeroObjectWithGivenZeroObject( cat, T, ZeroObject( cat ) );
    
end : Description := "UniversalMorphismIntoZeroObject by calling UniversalMorphismIntoZeroObjectWithGivenZeroObject with ZeroObject as last argument" );

##
AddDerivationToCAP( UniversalMorphismFromZeroObjectWithGivenZeroObject,
                    [ [ UniversalMorphismFromZeroObject, 1 ] ],
  function( cat, T, with_given_object )
    
    return UniversalMorphismFromZeroObject( cat, T );
    
end : Description := "UniversalMorphismFromZeroObjectWithGivenZeroObject by calling UniversalMorphismFromZeroObject with the last argument dropped" );

##
AddDerivationToCAP( UniversalMorphismFromZeroObject,
                    [ [ UniversalMorphismFromZeroObjectWithGivenZeroObject, 1 ],
                      [ ZeroObject, 1 ] ],
  function( cat, T )
    
    return UniversalMorphismFromZeroObjectWithGivenZeroObject( cat, T, ZeroObject( cat ) );
    
end : Description := "UniversalMorphismFromZeroObject by calling UniversalMorphismFromZeroObjectWithGivenZeroObject with ZeroObject as last argument" );
