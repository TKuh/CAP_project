# SPDX-License-Identifier: GPL-2.0-or-later
# CAP: Categories, Algorithms, Programming
#
# Implementations
#

InstallGlobalFunction( "CAP_INTERNAL_GENERATE_CONVENIENCE_METHODS_FOR_LIMITS",
  function ( package_name, method_name_record, limits )
    local output_string, generate_with_given_derivation, generate_functorial_convenience_method, number_of_diagram_arguments, functorial_record, filter_list, input_type, replaced_filter_list, replaced_filter_list_string, arguments_string, source_diagram_arguments_string, range_diagram_arguments_string, source_diagram_input_type, range_diagram_input_type, limit, existing_string, output_path;
    
    output_string :=
"""# SPDX-License-Identifier: GPL-2.0-or-later
# CAP: Categories, Algorithms, Programming
#
# Implementations
#
# THIS FILE IS AUTOMATICALLY GENERATED, SEE LimitConvenience.gi""";
    
    #### helper functions
    generate_with_given_derivation := function( without_given_name )
      local without_given_record, with_given_name, object_name, arguments, object_arguments, arguments_string, object_arguments_string, current_string;
        
        without_given_record := method_name_record.(without_given_name);
        
        with_given_name := without_given_record.with_given_without_given_name_pair[2];
        
        object_name := method_name_record.(with_given_name).with_given_object_name;
        
        arguments := Concatenation( [ "cat" ], without_given_record.io_type[1] );
        
        object_arguments := arguments{without_given_record.object_arguments_positions};
        
        arguments_string := JoinStringsWithSeparator( arguments, ", " );
        
        object_arguments_string := JoinStringsWithSeparator( object_arguments, ", " );
        
        current_string := Concatenation(
            "\n",
            "##\n",
            "AddDerivationToCAP( ", with_given_name, ",\n",
            "                    [ [ ", without_given_name, ", 1 ] ],\n",
            "  function( ", arguments_string, ", with_given_object )\n",
            "    \n",
            "    return ", without_given_name, "( ", arguments_string, " );\n",
            "    \n",
            "end : Description := \"", with_given_name, " by calling ", without_given_name, " with the last argument dropped\" );\n",
            "\n",
            "##\n",
            "AddDerivationToCAP( ", without_given_name, ",\n",
            "                    [ [ ", with_given_name, ", 1 ],\n",
            "                      [ ", object_name, ", 1 ] ],\n",
            "  function( ", arguments_string, " )\n",
            "    \n",
            "    return ", with_given_name, "( ", arguments_string, ", ", object_name, "( ", object_arguments_string, " ) );\n",
            "    \n",
            "end : Description := \"", without_given_name, " by calling ", with_given_name, " with ", object_name, " as last argument\" );\n"
        );
        
        output_string := Concatenation( output_string, current_string );
        
    end;
    
    generate_functorial_convenience_method := function( object_name, functorial_name, functorial_with_given_name, filter_list_string, arguments_string, source_diagram_arguments_string, range_diagram_arguments_string )
      local current_string;
        
        current_string := Concatenation(
            "\n",
            "##\n",
            "InstallMethod( ", functorial_name, ",\n",
            "               [ ", filter_list_string, " ],\n",
            "               \n",
            "  function( ", arguments_string, " )\n",
            "    \n",
            "    return ", functorial_with_given_name, "(\n",
            "        ", object_name, "( ", source_diagram_arguments_string, " ),\n",
            "        ", arguments_string, ",\n",
            "        ", object_name, "( ", range_diagram_arguments_string, " )\n",
            "    );\n",
            "    \n",
            "end );\n"
        );
        
        output_string := Concatenation( output_string, current_string );
        
    end;
    
    for limit in limits do
        
        number_of_diagram_arguments := Length( limit.diagram_filter_list );
        
        #### WithGiven derivations
        
        # limit
        if limit.number_of_targets > 0 then
            generate_with_given_derivation( limit.limit_projection_name );
        fi;
        
        if limit.number_of_nontargets = 1 then
            generate_with_given_derivation( limit.limit_morphism_to_sink_name );
        fi;
        
        generate_with_given_derivation( limit.limit_universal_morphism_name );
        
        # colimit
        if limit.number_of_targets > 0 then
            generate_with_given_derivation( limit.colimit_injection_name );
        fi;
        
        if limit.number_of_nontargets = 1 then
            generate_with_given_derivation( limit.colimit_morphism_from_source_name );
        fi;
        
        generate_with_given_derivation( limit.colimit_universal_morphism_name );
        
        
        if number_of_diagram_arguments > 0 then
            
            #### functorial convenience method
            functorial_record := method_name_record.( limit.limit_functorial_with_given_name );
            filter_list := functorial_record.filter_list;
            input_type := functorial_record.io_type[1];
            # the first entry is the category, the second and the last entries are the WithGiven-objects
            filter_list := filter_list{ [ 3 .. Length( filter_list ) - 1 ] };
            input_type := input_type{ [ 2 .. Length( input_type ) - 1 ] };
            
            replaced_filter_list := CAP_INTERNAL_REPLACE_STRINGS_WITH_FILTERS( filter_list );
            replaced_filter_list_string := JoinStringsWithSeparator( List( replaced_filter_list, NameFunction ), ", " );
            arguments_string := JoinStringsWithSeparator( input_type, ", " );
            
            if limit.number_of_unbound_morphisms = 0 then
                # derive diagrams from arguments
                if limit.number_of_targets = 1 then
                    source_diagram_arguments_string := Concatenation( "Source( ", arguments_string, " )" );
                    range_diagram_arguments_string := Concatenation( "Range( ", arguments_string, " )" );
                else
                    source_diagram_arguments_string := Concatenation( "List( ", arguments_string, ", Source )" );
                    range_diagram_arguments_string := Concatenation( "List( ", arguments_string, ", Range )" );
                fi;
            else
                # diagrams are passed as first and last argument(s)
                source_diagram_input_type := input_type{ [ 1 .. number_of_diagram_arguments ] };
                range_diagram_input_type := input_type{ [ (Length( input_type ) - number_of_diagram_arguments + 1) .. Length( input_type ) ] };

                source_diagram_arguments_string := JoinStringsWithSeparator( source_diagram_input_type, ", " );
                range_diagram_arguments_string := JoinStringsWithSeparator( range_diagram_input_type, ", " );
            fi;
            
            # limit
            generate_functorial_convenience_method( limit.limit_object_name, limit.limit_functorial_name, limit.limit_functorial_with_given_name, replaced_filter_list_string, arguments_string, source_diagram_arguments_string, range_diagram_arguments_string );
            
            # colimit
            if limit.limit_object_name <> limit.colimit_object_name then
                generate_functorial_convenience_method( limit.colimit_object_name, limit.colimit_functorial_name, limit.colimit_functorial_with_given_name, replaced_filter_list_string, arguments_string, source_diagram_arguments_string, range_diagram_arguments_string );
            fi;
            
        fi;
        
    od;
    
    existing_string := ReadFileFromPackageForHomalg( package_name, "LimitConvenienceOutput.gi" );
    
    if output_string <> existing_string then
        
        output_path := Filename( DirectoryTemporary( ), "LimitConvenienceOutput.gi" );
        
        WriteFileForHomalg( output_path, output_string );
        
        Display( Concatenation(
            "WARNING: The file LimitConvenienceOutput.gi differs from the automatically generated one. ",
            "You can view the automatically generated file at the following path: ",
            output_path
        ) );
        
    fi;
    
end );

CAP_INTERNAL_GENERATE_CONVENIENCE_METHODS_FOR_LIMITS( "CAP", CAP_INTERNAL_METHOD_NAME_RECORD, CAP_INTERNAL_METHOD_NAME_RECORD_LIMITS );
