# SPDX-License-Identifier: GPL-2.0-or-later
# CAP: Categories, Algorithms, Programming
#
# Implementations
#

InstallGlobalFunction( "CAP_INTERNAL_GENERATE_CONVENIENCE_METHODS_FOR_LIMITS",
  function ( package_name, method_name_record, limits )
    local output_string, generate_with_given_derivation, generate_universal_morphism_convenience, generate_functorial_convenience_method, number_of_diagram_arguments, functorial_record, filter_list, input_type, replaced_filter_list, replaced_filter_list_string, arguments_string, source_diagram_arguments_string, range_diagram_arguments_string, source_diagram_input_type, range_diagram_input_type, call_arguments_string, limit, existing_string, output_path;
    
    output_string :=
"""# SPDX-License-Identifier: GPL-2.0-or-later
# CAP: Categories, Algorithms, Programming
#
# Implementations
#
# THIS FILE IS AUTOMATICALLY GENERATED, SEE LimitConvenience.gi""";
    
    #### helper functions
    generate_with_given_derivation := function( without_given_name )
      local without_given_record, with_given_name, object_name, arguments, object_arguments, arguments_string, object_arguments_string, current_string;
        
        without_given_record := method_name_record.(without_given_name);
        
        with_given_name := without_given_record.with_given_without_given_name_pair[2];
        
        object_name := method_name_record.(with_given_name).with_given_object_name;
        
        arguments := Concatenation( [ "cat" ], without_given_record.io_type[1] );
        
        object_arguments := arguments{without_given_record.object_arguments_positions};
        
        arguments_string := JoinStringsWithSeparator( arguments, ", " );
        
        object_arguments_string := JoinStringsWithSeparator( object_arguments, ", " );
        
        current_string := Concatenation(
            "\n",
            "##\n",
            "AddDerivationToCAP( ", with_given_name, ",\n",
            "                    [ [ ", without_given_name, ", 1 ] ],\n",
            "  function( ", arguments_string, ", with_given_object )\n",
            "    \n",
            "    return ", without_given_name, "( ", arguments_string, " );\n",
            "    \n",
            "end : Description := \"", with_given_name, " by calling ", without_given_name, " with the last argument dropped\" );\n",
            "\n",
            "##\n",
            "AddDerivationToCAP( ", without_given_name, ",\n",
            "                    [ [ ", with_given_name, ", 1 ],\n",
            "                      [ ", object_name, ", 1 ] ],\n",
            "  function( ", arguments_string, " )\n",
            "    \n",
            "    return ", with_given_name, "( ", arguments_string, ", ", object_name, "( ", object_arguments_string, " ) );\n",
            "    \n",
            "end : Description := \"", without_given_name, " by calling ", with_given_name, " with ", object_name, " as last argument\" );\n"
        );
        
        output_string := Concatenation( output_string, current_string );
        
    end;
    
    generate_universal_morphism_convenience := function( universal_morphism_name, number_of_unbound_morphisms, number_of_targets, diagram_position, diagram_filter_list )
      local current_string, replaced_filter_list, replaced_filter_list_string;
        
        if not diagram_position in [ "Source", "Range" ] then
            
            Error( "diagram_position must be \"Source\" or \"Range\"" );
            
        fi;
        
        if number_of_unbound_morphisms = 0 then
            
            # diagram can be derived from morphism(s) via diagram_position
            
            if number_of_targets = 1 then
                
                Error( "this case is currently not supported" );
                
            elif number_of_targets > 1 then
                
                # derive diagram from morphisms via diagram_position
                current_string := Concatenation(
                    "\n",
                    "##\n",
                    "InstallMethod( ", universal_morphism_name, ",\n",
                    "               [ IsList ],\n",
                    "               \n",
                    "  function( list )\n",
                    "    #% CAP_JIT_RESOLVE_FUNCTION\n",
                    "    \n",
                    "    return ", universal_morphism_name, "( CapCategory( list[1] ), list );\n",
                    "    \n",
                    "end );\n",
                    "\n",
                    "##\n",
                    "InstallOtherMethod( ", universal_morphism_name, ",\n",
                    "               [ IsCapCategory, IsList ],\n",
                    "               \n",
                    "  function( cat, list )\n",
                    "    #% CAP_JIT_RESOLVE_FUNCTION\n",
                    "    \n",
                    "    return ", universal_morphism_name, "( cat, List( list, ", diagram_position, " ), list );\n",
                    "    \n",
                    "end );\n"
                );
                
                output_string := Concatenation( output_string, current_string );
                
                # redirect UniversalMorphism( mor1, mor2, ... ) to UniversalMorphism( [ mor1, mor2, ... ] )
                current_string := Concatenation(
                    "\n",
                    "##\n",
                    "InstallOtherMethod( ", universal_morphism_name, ",\n",
                    "               [ IsCapCategoryMorphism ],\n",
                    "               \n",
                    "  function( mor1 )\n",
                    "    \n",
                    "    Print(\n",
                    "      Concatenation(\n",
                    "      \"WARNING: ", universal_morphism_name, "( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. \",\n",
                    "      \"Please use ", universal_morphism_name, "( [ IsCapCategoryMorphism, ... ] ) instead.\\n\"\n",
                    "      )\n",
                    "    );\n",
                    "    \n",
                    "    return ", universal_morphism_name, "( [ mor1 ] );\n",
                    "    \n",
                    "end );\n",
                    "\n",
                    "##\n",
                    "InstallOtherMethod( ", universal_morphism_name, ",\n",
                    "               [ IsCapCategoryMorphism, IsCapCategoryMorphism ],\n",
                    "               \n",
                    "  function( mor1, mor2 )\n",
                    "    \n",
                    "    Print(\n",
                    "      Concatenation(\n",
                    "      \"WARNING: ", universal_morphism_name, "( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. \",\n",
                    "      \"Please use ", universal_morphism_name, "( [ IsCapCategoryMorphism, ... ] ) instead.\\n\"\n",
                    "      )\n",
                    "    );\n",
                    "    \n",
                    "    return ", universal_morphism_name, "( [ mor1, mor2 ] );\n",
                    "    \n",
                    "end );\n",
                    "\n",
                    "##\n",
                    "InstallOtherMethod( ", universal_morphism_name, ",\n",
                    "               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],\n",
                    "               \n",
                    "  function( mor1, mor2, mor3 )\n",
                    "    \n",
                    "    Print(\n",
                    "      Concatenation(\n",
                    "      \"WARNING: ", universal_morphism_name, "( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. \",\n",
                    "      \"Please use ", universal_morphism_name, "( [ IsCapCategoryMorphism, ... ] ) instead.\\n\"\n",
                    "      )\n",
                    "    );\n",
                    "    \n",
                    "    return ", universal_morphism_name, "( [ mor1, mor2, mor3 ] );\n",
                    "    \n",
                    "end );\n",
                    "\n",
                    "##\n",
                    "InstallOtherMethod( ", universal_morphism_name, ",\n",
                    "               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],\n",
                    "               \n",
                    "  function( mor1, mor2, mor3, mor4 )\n",
                    "    \n",
                    "    Print(\n",
                    "      Concatenation(\n",
                    "      \"WARNING: ", universal_morphism_name, "( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. \",\n",
                    "      \"Please use ", universal_morphism_name, "( [ IsCapCategoryMorphism, ... ] ) instead.\\n\"\n",
                    "      )\n",
                    "    );\n",
                    "    \n",
                    "    return ", universal_morphism_name, "( [ mor1, mor2, mor3, mor4 ] );\n",
                    "    \n",
                    "end );\n",
                    "\n",
                    "##\n",
                    "InstallOtherMethod( ", universal_morphism_name, ",\n",
                    "               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],\n",
                    "               \n",
                    "  function( mor1, mor2, mor3, mor4, mor5 )\n",
                    "    \n",
                    "    Print(\n",
                    "      Concatenation(\n",
                    "      \"WARNING: ", universal_morphism_name, "( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. \",\n",
                    "      \"Please use ", universal_morphism_name, "( [ IsCapCategoryMorphism, ... ] ) instead.\\n\"\n",
                    "      )\n",
                    "    );\n",
                    "    \n",
                    "    return ", universal_morphism_name, "( [ mor1, mor2, mor3, mor4, mor5 ] );\n",
                    "    \n",
                    "end );\n",
                    "\n",
                    "##\n",
                    "InstallOtherMethod( ", universal_morphism_name, ",\n",
                    "               [ IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism, IsCapCategoryMorphism ],\n",
                    "               \n",
                    "  function( mor1, mor2, mor3, mor4, mor5, mor6 )\n",
                    "    \n",
                    "    Print(\n",
                    "      Concatenation(\n",
                    "      \"WARNING: ", universal_morphism_name, "( IsCapCategoryMorphism, ... ) is deprecated and will not be supported after 2022.04.15. \",\n",
                    "      \"Please use ", universal_morphism_name, "( [ IsCapCategoryMorphism, ... ] ) instead.\\n\"\n",
                    "      )\n",
                    "    );\n",
                    "    \n",
                    "    return ", universal_morphism_name, "( [ mor1, mor2, mor3, mor4, mor5, mor6 ] );\n",
                    "    \n",
                    "end );\n"
                );
                
                output_string := Concatenation( output_string, current_string );
                
            fi;
            
        fi;
        
    end;
    
    generate_functorial_convenience_method := function( object_name, functorial_name, functorial_with_given_name, filter_list_string, arguments_string, source_diagram_arguments_string, range_diagram_arguments_string, call_arguments_string )
      local current_string;
        
        current_string := Concatenation(
            "\n",
            "##\n",
            "InstallMethod( ", functorial_name, ",\n",
            "               [ ", filter_list_string, " ],\n",
            "               \n",
            "  function( ", arguments_string, " )\n",
            "    \n",
            "    return ", functorial_with_given_name, "(\n",
            "        ", object_name, "( ", source_diagram_arguments_string, " ),\n",
            "        ", call_arguments_string, ",\n",
            "        ", object_name, "( ", range_diagram_arguments_string, " )\n",
            "    );\n",
            "    \n",
            "end );\n"
        );
        
        output_string := Concatenation( output_string, current_string );
        
        current_string := Concatenation(
            "\n",
            "##\n",
            "InstallOtherMethod( ", functorial_name, ",\n",
            "               [ IsCapCategory, ", filter_list_string, " ],\n",
            "               \n",
            "  function( cat, ", arguments_string, " )\n",
            "    #% CAP_JIT_RESOLVE_FUNCTION\n",
            "    \n",
            "    return ", functorial_with_given_name, "(\n",
            "        cat,\n",
            "        ", object_name, "( cat, ", source_diagram_arguments_string, " ),\n",
            "        ", call_arguments_string, ",\n",
            "        ", object_name, "( cat, ", range_diagram_arguments_string, " )\n",
            "    );\n",
            "    \n",
            "end );\n"
        );
        
        output_string := Concatenation( output_string, current_string );
        
    end;
    
    for limit in limits do
        
        number_of_diagram_arguments := Length( limit.diagram_filter_list );
        
        #### WithGiven derivations
        
        # limit
        if limit.number_of_targets > 0 then
            generate_with_given_derivation( limit.limit_projection_name );
        fi;
        
        if limit.number_of_nontargets = 1 then
            generate_with_given_derivation( limit.limit_morphism_to_sink_name );
        fi;
        
        generate_with_given_derivation( limit.limit_universal_morphism_name );
        
        # colimit
        if limit.number_of_targets > 0 then
            generate_with_given_derivation( limit.colimit_injection_name );
        fi;
        
        if limit.number_of_nontargets = 1 then
            generate_with_given_derivation( limit.colimit_morphism_from_source_name );
        fi;
        
        generate_with_given_derivation( limit.colimit_universal_morphism_name );
        
        
        if number_of_diagram_arguments > 0 then
            
            #### universal morphism convenience
            generate_universal_morphism_convenience( limit.limit_universal_morphism_name, limit.number_of_unbound_morphisms, limit.number_of_targets, "Range", limit.diagram_filter_list );
            generate_universal_morphism_convenience( limit.colimit_universal_morphism_name, limit.number_of_unbound_morphisms, limit.number_of_targets, "Source", limit.diagram_filter_list );
            
            #### functorial convenience method
            functorial_record := method_name_record.( limit.limit_functorial_with_given_name );
            
            if limit.number_of_unbound_morphisms = 0 then
                # derive diagrams from arguments
                filter_list := limit.diagram_morphism_filter_list;
                input_type := limit.diagram_morphism_input_type;

                Assert( 0, Length( filter_list ) = 1 );
                Assert( 0, Length( input_type ) = 1 );

                arguments_string := JoinStringsWithSeparator( input_type, ", " );

                if limit.number_of_targets = 1 then
                    source_diagram_arguments_string := Concatenation( "Source( ", arguments_string, " )" );
                    range_diagram_arguments_string := Concatenation( "Range( ", arguments_string, " )" );
                else
                    source_diagram_arguments_string := Concatenation( "List( ", arguments_string, ", Source )" );
                    range_diagram_arguments_string := Concatenation( "List( ", arguments_string, ", Range )" );
                fi;
                
                call_arguments_string := JoinStringsWithSeparator( [ source_diagram_arguments_string, arguments_string, range_diagram_arguments_string ], ", " );
            else
                filter_list := functorial_record.filter_list;
                input_type := functorial_record.io_type[1];
                # the first entry is the category, the second and the last entries are the WithGiven-objects
                filter_list := filter_list{ [ 3 .. Length( filter_list ) - 1 ] };
                input_type := input_type{ [ 2 .. Length( input_type ) - 1 ] };
                
                arguments_string := JoinStringsWithSeparator( input_type, ", " );

                # diagrams are passed as first and last argument(s)
                source_diagram_input_type := input_type{ [ 1 .. number_of_diagram_arguments ] };
                range_diagram_input_type := input_type{ [ (Length( input_type ) - number_of_diagram_arguments + 1) .. Length( input_type ) ] };

                source_diagram_arguments_string := JoinStringsWithSeparator( source_diagram_input_type, ", " );
                range_diagram_arguments_string := JoinStringsWithSeparator( range_diagram_input_type, ", " );

                call_arguments_string := arguments_string;
            fi;
            
            replaced_filter_list := CAP_INTERNAL_REPLACE_STRINGS_WITH_FILTERS( filter_list );
            replaced_filter_list_string := JoinStringsWithSeparator( List( replaced_filter_list, NameFunction ), ", " );
            
            # limit
            generate_functorial_convenience_method( limit.limit_object_name, limit.limit_functorial_name, limit.limit_functorial_with_given_name, replaced_filter_list_string, arguments_string, source_diagram_arguments_string, range_diagram_arguments_string, call_arguments_string );
            
            # colimit
            if limit.limit_object_name <> limit.colimit_object_name then
                generate_functorial_convenience_method( limit.colimit_object_name, limit.colimit_functorial_name, limit.colimit_functorial_with_given_name, replaced_filter_list_string, arguments_string, source_diagram_arguments_string, range_diagram_arguments_string, call_arguments_string );
            fi;
            
        fi;
        
    od;
    
    existing_string := ReadFileFromPackageForHomalg( package_name, "LimitConvenienceOutput.gi" );
    
    if output_string <> existing_string then
        
        output_path := Filename( DirectoryTemporary( ), "LimitConvenienceOutput.gi" );
        
        WriteFileForHomalg( output_path, output_string );
        
        Display( Concatenation(
            "WARNING: The file LimitConvenienceOutput.gi differs from the automatically generated one. ",
            "You can view the automatically generated file at the following path: ",
            output_path
        ) );
        
    fi;
    
end );

CAP_INTERNAL_GENERATE_CONVENIENCE_METHODS_FOR_LIMITS( "CAP", CAP_INTERNAL_METHOD_NAME_RECORD, CAP_INTERNAL_METHOD_NAME_RECORD_LIMITS );
